class ArizonaHierarchical {
  constructor() {
    this.structure = /* @__PURE__ */ new Map();
  }
  /**
   * Initialize with hierarchical structure from server
   * @param {Object} structure - Hierarchical structure from arizona_hierarchical
   */
  initialize(structure) {
    this.structure = new Map(Object.entries(JSON.parse(JSON.stringify(structure))));
  }
  /**
   * Apply diff changes from arizona_differ to hierarchical structure
   * @param {string} statefulId - Stateful ID to render
   * @param {Array|Object} changes - Changes in format: [[ElementIndex, Changes]] or hierarchical structure
   */
  applyDiff(statefulId, changes) {
    if (changes?.type === "stateful") {
      this.structure.set(changes.id, changes);
      return;
    }
    if (!this.structure.has(statefulId)) {
      const sanitizedStatefulId = String(statefulId).replace(/\r|\n/g, "");
      console.warn(`[Arizona] StatefulId '${sanitizedStatefulId}' not found in structure`);
    }
    for (const [elementIndex, newValue] of changes) {
      if (newValue && typeof newValue === "object" && newValue.type) {
        this.structure.get(statefulId).dynamic[elementIndex - 1] = newValue;
      } else if (Array.isArray(newValue)) {
        const element = this.structure.get(statefulId).dynamic[elementIndex - 1];
        if (element && element.type === "list") {
          this.structure.get(statefulId).dynamic[elementIndex - 1].dynamic = newValue;
        } else if (element && element.type === "stateless") {
          newValue.forEach(([index, value]) => {
            this.structure.get(statefulId).dynamic[elementIndex - 1].dynamic[index - 1] = value;
          });
        } else {
          this.structure.get(statefulId).dynamic[elementIndex - 1] = newValue;
        }
      } else {
        this.structure.get(statefulId).dynamic[elementIndex - 1] = newValue;
      }
    }
  }
  /**
   * Generate HTML for stateful components
   * @param {Object} element - Stateful element with id
   * @returns {string} Generated HTML
   */
  generateStatefulHTML(statefulId) {
    const struct = this.structure.get(statefulId);
    if (!struct) {
      const sanitizedStatefulId = String(statefulId).replace(/\r|\n/g, "");
      console.warn(`[Arizona] StatefulId '${sanitizedStatefulId}' not found in structure`);
    }
    return this.zipStaticDynamic(struct.static, struct.dynamic);
  }
  /**
   * Generate HTML for stateless components
   * @param {Object} element - Stateless element with static and dynamic arrays
   * @returns {string} Generated HTML
   */
  generateStatelessHTML(element) {
    return this.zipStaticDynamic(element.static, element.dynamic);
  }
  /**
   * Generate HTML for list components
   * @param {Object} listElement - List element with static template and dynamic data
   * @returns {string} Generated HTML
   */
  generateListHTML(listElement) {
    const { static: staticParts, dynamic: dynamicPartsList } = listElement;
    return dynamicPartsList.reduce((acc, dynamicParts) => {
      return acc + this.zipStaticDynamic(staticParts, dynamicParts);
    }, "");
  }
  /**
   * Zip static and dynamic arrays into HTML (matches arizona_renderer:zip_static_dynamic/2)
   * @param {Array} staticParts - Static HTML parts
   * @param {Array} dynamicParts - Dynamic content parts
   * @returns {string} Generated HTML
   */
  zipStaticDynamic(staticParts, dynamicParts) {
    const elements = [];
    const maxLength = Math.max(staticParts.length, dynamicParts.length);
    for (let i = 0; i < maxLength; i++) {
      if (i < staticParts.length) {
        elements.push(staticParts[i]);
      }
      if (i < dynamicParts.length) {
        elements.push(this.normalizeDynamicElement(dynamicParts[i]));
      }
    }
    return elements.join("");
  }
  /**
   * Normalize a dynamic element to string (handles stateful, stateless, lists, etc.)
   * @param {*} element - Dynamic element to normalize
   * @returns {string} Normalized string content
   */
  normalizeDynamicElement(element) {
    if (typeof element === "string") {
      return element;
    } else if (element && element.type === "stateful") {
      return this.generateStatefulHTML(element.id);
    } else if (element && element.type === "stateless") {
      return this.generateStatelessHTML(element);
    } else if (element && element.type === "list") {
      return this.generateListHTML(element);
    } else if (Array.isArray(element)) {
      return this.flattenIoData(element);
    } else {
      return String(element);
    }
  }
  /**
   * Flatten nested arrays (iodata from Erlang server) into a single string
   * This handles the complex nested array structures that come from render_list
   * and other server-side rendering operations that produce iodata.
   *
   * @param {Array|string|number} element - Element to flatten
   * @returns {string} Flattened string without commas between array elements
   */
  flattenIoData(element) {
    if (typeof element === "string") {
      return element;
    } else if (typeof element === "number") {
      return String(element);
    } else if (Array.isArray(element)) {
      return element.map((item) => {
        return this.flattenIoData(item);
      }).join("");
    } else if (element && typeof element === "object") {
      if (element.type === "stateful") {
        return this.generateStatefulHTML(element.id);
      } else if (element.type === "stateless") {
        return this.generateStatelessHTML(element);
      } else if (element.type === "list") {
        return this.generateListHTML(element);
      } else {
        return String(element);
      }
    } else {
      return String(element || "");
    }
  }
  /**
   * Get current structure (for debugging/testing)
   * @returns {Object} Deep copy of current structure
   */
  getStructure() {
    return JSON.parse(JSON.stringify(Object.fromEntries(this.structure)));
  }
  /**
   * Check if structure has been initialized
   * @returns {boolean} True if structure contains any components
   */
  isInitialized() {
    return this.structure.size > 0;
  }
  /**
   * Get all component IDs
   * @returns {string[]} Array of all component IDs
   */
  getComponentIds() {
    return Array.from(this.structure.keys());
  }
  /**
   * Clear all structure data
   */
  clear() {
    this.structure = /* @__PURE__ */ new Map();
  }
  /**
   * Create a patch object that can be sent to arizona.js for DOM updating
   * This is used by the worker to send structured data to the main thread
   * @param {string} statefulId - Stateful ID to render
   * @returns {Object} Patch object with statefulId and HTML
   */
  createPatch(statefulId) {
    return {
      type: "html_patch",
      statefulId,
      html: this.generateStatefulHTML(statefulId)
    };
  }
}
class ArizonaWebSocketWorker {
  constructor() {
    this.socket = null;
    this.connected = false;
    this.messageQueue = [];
    this.hierarchical = new ArizonaHierarchical();
    self.onmessage = (event) => {
      const { type, data } = event.data;
      switch (type) {
        case "connect":
          this.connect(data.url);
          break;
        case "send":
          this.sendMessage(data);
          break;
        case "disconnect":
          this.disconnect();
          break;
      }
    };
  }
  connect(url) {
    if (this.connected) return;
    this.socket = new WebSocket(url);
    this.socket.onopen = () => {
      this.connected = true;
      this.postMessage({ type: "status", data: { status: "connected" } });
      this.flushMessageQueue();
    };
    this.socket.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleWebSocketMessage(message);
    };
    this.socket.onclose = () => {
      this.connected = false;
      this.postMessage({ type: "status", data: { status: "disconnected" } });
    };
    this.socket.onerror = (error) => {
      this.postMessage({ type: "error", data: { error: error.toString() } });
    };
  }
  sendMessage(data) {
    const message = JSON.stringify(data);
    if (this.connected && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(message);
    } else {
      this.messageQueue.push(message);
    }
  }
  flushMessageQueue() {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      if (this.socket.readyState === WebSocket.OPEN) {
        this.socket.send(message);
      } else {
        this.messageQueue.unshift(message);
        break;
      }
    }
  }
  disconnect() {
    if (this.socket) {
      this.socket.close();
      this.socket = null;
    }
    this.connected = false;
    this.hierarchical.clear();
  }
  handleWebSocketMessage(message) {
    try {
      switch (message.type) {
        case "initial_render":
          this.handleInitialRender(message);
          break;
        case "diff":
          this.handleDiff(message);
          break;
        case "reload":
          this.handleReload(message);
          break;
        case "reply":
          this.handleReply(message);
          break;
        case "redirect":
          this.handleRedirect(message);
          break;
        default:
          this.handleUnknownMessage(message);
      }
    } catch (error) {
      this.postMessage({
        type: "error",
        data: { error: `Message handling failed: ${error.message}` }
      });
    }
  }
  handleInitialRender(message) {
    this.hierarchical.initialize(message.structure);
  }
  handleDiff(message) {
    if (!this.hierarchical.isInitialized()) {
      throw new Error("Hierarchical structure not initialized");
    }
    this.hierarchical.applyDiff(message.stateful_id, message.changes);
    const patch = this.hierarchical.createPatch(message.stateful_id);
    this.postMessage({
      type: "html_patch",
      data: { patch }
    });
  }
  handleReload(message) {
    this.postMessage({
      type: "reload",
      data: message
    });
  }
  handleReply(message) {
    this.postMessage({
      type: "reply",
      data: message.data
    });
  }
  handleRedirect(message) {
    this.postMessage({
      type: "redirect",
      data: {
        url: message.url,
        target: message.target
      }
    });
  }
  handleUnknownMessage(message) {
    this.postMessage(message);
  }
  postMessage(data) {
    self.postMessage(data);
  }
}
new ArizonaWebSocketWorker();
//# sourceMappingURL=arizona-worker.min.js.map
