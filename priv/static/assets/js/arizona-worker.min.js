class h {
  constructor() {
    this.structure = /* @__PURE__ */ new Map();
  }
  /**
   * Initialize with hierarchical structure from server
   * @param {Object} structure - Hierarchical structure from arizona_hierarchical
   */
  initialize(t) {
    this.structure = new Map(Object.entries(JSON.parse(JSON.stringify(t))));
  }
  /**
   * Apply diff changes from arizona_differ to hierarchical structure
   * @param {string} statefulId - Stateful ID to render
   * @param {Array|Object} changes - Changes in format: [[ElementIndex, Changes]] or hierarchical structure
   */
  applyDiff(t, e) {
    if (e?.type === "stateful") {
      this.structure.set(e.id, e);
      return;
    }
    if (!this.structure.has(t)) {
      const s = String(t).replace(/\r|\n/g, "");
      console.warn(`[Arizona] StatefulId '${s}' not found in structure`);
    }
    for (const [s, i] of e)
      if (i && typeof i == "object" && i.type)
        this.structure.get(t).dynamic[s - 1] = i;
      else if (Array.isArray(i)) {
        const r = this.structure.get(t).dynamic[s - 1];
        r && r.type === "list" ? this.structure.get(t).dynamic[s - 1].dynamic = i : r && r.type === "stateless" ? i.forEach(([n, c]) => {
          this.structure.get(t).dynamic[s - 1].dynamic[n - 1] = c;
        }) : this.structure.get(t).dynamic[s - 1] = i;
      } else
        this.structure.get(t).dynamic[s - 1] = i;
  }
  /**
   * Generate HTML for stateful components
   * @param {Object} element - Stateful element with id
   * @returns {string} Generated HTML
   */
  generateStatefulHTML(t) {
    const e = this.structure.get(t);
    if (!e) {
      const s = String(t).replace(/\r|\n/g, "");
      console.warn(`[Arizona] StatefulId '${s}' not found in structure`);
    }
    return this.zipStaticDynamic(e.static, e.dynamic);
  }
  /**
   * Generate HTML for stateless components
   * @param {Object} element - Stateless element with static and dynamic arrays
   * @returns {string} Generated HTML
   */
  generateStatelessHTML(t) {
    return this.zipStaticDynamic(t.static, t.dynamic);
  }
  /**
   * Generate HTML for list components
   * @param {Object} listElement - List element with static template and dynamic data
   * @returns {string} Generated HTML
   */
  generateListHTML(t) {
    const { static: e, dynamic: s } = t;
    return s.reduce((i, r) => i + this.zipStaticDynamic(e, r), "");
  }
  /**
   * Zip static and dynamic arrays into HTML (matches arizona_renderer:zip_static_dynamic/2)
   * @param {Array} staticParts - Static HTML parts
   * @param {Array} dynamicParts - Dynamic content parts
   * @returns {string} Generated HTML
   */
  zipStaticDynamic(t, e) {
    const s = [], i = Math.max(t.length, e.length);
    for (let r = 0; r < i; r++)
      r < t.length && s.push(t[r]), r < e.length && s.push(this.normalizeDynamicElement(e[r]));
    return s.join("");
  }
  /**
   * Normalize a dynamic element to string (handles stateful, stateless, lists, etc.)
   * @param {*} element - Dynamic element to normalize
   * @returns {string} Normalized string content
   */
  normalizeDynamicElement(t) {
    return typeof t == "string" ? t : t && t.type === "stateful" ? this.generateStatefulHTML(t.id) : t && t.type === "stateless" ? this.generateStatelessHTML(t) : t && t.type === "list" ? this.generateListHTML(t) : Array.isArray(t) ? this.flattenIoData(t) : String(t);
  }
  /**
   * Flatten nested arrays (iodata from Erlang server) into a single string
   * This handles the complex nested array structures that come from render_list
   * and other server-side rendering operations that produce iodata.
   *
   * @param {Array|string|number} element - Element to flatten
   * @returns {string} Flattened string without commas between array elements
   */
  flattenIoData(t) {
    return typeof t == "string" ? t : typeof t == "number" ? String(t) : Array.isArray(t) ? t.map((e) => this.flattenIoData(e)).join("") : t && typeof t == "object" ? t.type === "stateful" ? this.generateStatefulHTML(t.id) : t.type === "stateless" ? this.generateStatelessHTML(t) : t.type === "list" ? this.generateListHTML(t) : String(t) : String(t || "");
  }
  /**
   * Get current structure (for debugging/testing)
   * @returns {Object} Deep copy of current structure
   */
  getStructure() {
    return JSON.parse(JSON.stringify(Object.fromEntries(this.structure)));
  }
  /**
   * Check if structure has been initialized
   * @returns {boolean} True if structure contains any components
   */
  isInitialized() {
    return this.structure.size > 0;
  }
  /**
   * Get all component IDs
   * @returns {string[]} Array of all component IDs
   */
  getComponentIds() {
    return Array.from(this.structure.keys());
  }
  /**
   * Clear all structure data
   */
  clear() {
    this.structure = /* @__PURE__ */ new Map();
  }
  /**
   * Create a patch object that can be sent to arizona.js for DOM updating
   * This is used by the worker to send structured data to the main thread
   * @param {string} statefulId - Stateful ID to render
   * @returns {Object} Patch object with statefulId and HTML
   */
  createPatch(t) {
    return {
      type: "html_patch",
      statefulId: t,
      html: this.generateStatefulHTML(t)
    };
  }
}
class o {
  constructor() {
    this.socket = null, this.connected = !1, this.messageQueue = [], this.hierarchical = new h(), self.onmessage = (t) => {
      const { type: e, data: s } = t.data;
      switch (e) {
        case "connect":
          this.connect(s.url);
          break;
        case "send":
          this.sendMessage(s);
          break;
        case "disconnect":
          this.disconnect();
          break;
      }
    };
  }
  connect(t) {
    this.connected || (this.socket = new WebSocket(t), this.socket.onopen = () => {
      this.connected = !0, this.postMessage({ type: "status", data: { status: "connected" } }), this.flushMessageQueue();
    }, this.socket.onmessage = (e) => {
      const s = JSON.parse(e.data);
      this.handleWebSocketMessage(s);
    }, this.socket.onclose = () => {
      this.connected = !1, this.postMessage({ type: "status", data: { status: "disconnected" } });
    }, this.socket.onerror = (e) => {
      this.postMessage({ type: "error", data: { error: e.toString() } });
    });
  }
  sendMessage(t) {
    const e = JSON.stringify(t);
    this.connected && this.socket.readyState === WebSocket.OPEN ? this.socket.send(e) : this.messageQueue.push(e);
  }
  flushMessageQueue() {
    for (; this.messageQueue.length > 0; ) {
      const t = this.messageQueue.shift();
      if (this.socket.readyState === WebSocket.OPEN)
        this.socket.send(t);
      else {
        this.messageQueue.unshift(t);
        break;
      }
    }
  }
  disconnect() {
    this.socket && (this.socket.close(), this.socket = null), this.connected = !1, this.hierarchical.clear();
  }
  handleWebSocketMessage(t) {
    try {
      switch (t.type) {
        case "initial_render":
          this.handleInitialRender(t);
          break;
        case "diff":
          this.handleDiff(t);
          break;
        case "reload":
          this.handleReload(t);
          break;
        case "reply":
          this.handleReply(t);
          break;
        case "redirect":
          this.handleRedirect(t);
          break;
        default:
          this.handleUnknownMessage(t);
      }
    } catch (e) {
      this.postMessage({
        type: "error",
        data: { error: `Message handling failed: ${e.message}` }
      });
    }
  }
  handleInitialRender(t) {
    this.hierarchical.initialize(t.structure);
  }
  handleDiff(t) {
    if (!this.hierarchical.isInitialized())
      throw new Error("Hierarchical structure not initialized");
    this.hierarchical.applyDiff(t.stateful_id, t.changes);
    const e = this.hierarchical.createPatch(t.stateful_id);
    this.postMessage({
      type: "html_patch",
      data: { patch: e }
    });
  }
  handleReload(t) {
    this.postMessage({
      type: "reload",
      data: t
    });
  }
  handleReply(t) {
    this.postMessage({
      type: "reply",
      data: t.data
    });
  }
  handleRedirect(t) {
    this.postMessage({
      type: "redirect",
      data: {
        url: t.url,
        target: t.target
      }
    });
  }
  handleUnknownMessage(t) {
    this.postMessage(t);
  }
  postMessage(t) {
    self.postMessage(t);
  }
}
new o();
//# sourceMappingURL=arizona-worker.min.js.map
