{
  "version": 3,
  "sources": ["../../../../assets/js/arizona-hierarchical.js", "../../../../assets/js/arizona-worker.js"],
  "sourcesContent": ["/**\n * Arizona Hierarchical Client\n *\n * Standalone module for managing hierarchical structures and HTML generation.\n * Used by both arizona-worker.js and arizona.js for consistent structure handling.\n *\n * Features:\n * - Initialize with hierarchical structures from WebSocket\n * - Apply diffs from arizona_differ to update structures\n * - Generate HTML from hierarchical structures\n * - Support for nested stateful/stateless components and lists\n */\n\n/**\n * ArizonaHierarchical - Client-side hierarchical structure manager\n */\nexport class ArizonaHierarchical {\n  constructor() {\n    this.structure = {};\n  }\n\n  /**\n   * Initialize with hierarchical structure from server\n   * @param {Object} structure - Hierarchical structure from arizona_hierarchical\n   */\n  initialize(structure) {\n    this.structure = JSON.parse(JSON.stringify(structure)); // Deep clone\n  }\n\n  /**\n   * Apply diff changes from arizona_differ to hierarchical structure\n   * @param {Array} changes - Changes in format: [[StatefulId, [[ElementIndex, Changes]]]]\n   */\n  applyDiff(changes) {\n    for (const [statefulId, elementChanges] of changes) {\n      if (!this.structure[statefulId]) {\n        console.warn(`[Arizona] StatefulId ${statefulId} not found in structure`);\n        continue;\n      }\n\n      for (const [elementIndex, newValue] of elementChanges) {\n        this.structure[statefulId][elementIndex] = newValue;\n      }\n    }\n  }\n\n  /**\n   * Generate HTML from current hierarchical structure\n   * @param {string} componentId - Component ID to render (defaults to 'root')\n   * @returns {string} Generated HTML\n   */\n  generateHTML(componentId = 'root') {\n    const component = this.structure[componentId];\n    if (!component) {\n      return '';\n    }\n\n    const elements = [];\n    const sortedIndexes = Object.keys(component)\n      .map((k) => parseInt(k))\n      .sort((a, b) => a - b);\n\n    for (const index of sortedIndexes) {\n      const element = component[index];\n\n      if (typeof element === 'string') {\n        elements.push(element);\n      } else if (element && element.type === 'stateful') {\n        // Recursively render nested stateful component\n        elements.push(this.generateHTML(element.id));\n      } else if (element && element.type === 'stateless') {\n        // Render stateless structure inline\n        elements.push(this.generateHTMLFromStructure(element.structure));\n      } else if (element && element.type === 'list') {\n        // Render list elements\n        elements.push(this.generateListHTML(element));\n      } else {\n        // Fallback for other types (numbers, etc.)\n        elements.push(String(element));\n      }\n    }\n\n    return elements.join('');\n  }\n\n  /**\n   * Generate HTML from a structure object (for stateless components)\n   * @param {Object} structure - Structure object with indexed elements\n   * @returns {string} Generated HTML\n   */\n  generateHTMLFromStructure(structure) {\n    const elements = [];\n    const sortedIndexes = Object.keys(structure)\n      .map((k) => parseInt(k))\n      .sort((a, b) => a - b);\n\n    for (const index of sortedIndexes) {\n      const element = structure[index];\n      if (typeof element === 'string') {\n        elements.push(element);\n      } else {\n        elements.push(String(element));\n      }\n    }\n\n    return elements.join('');\n  }\n\n  /**\n   * Generate HTML for list components\n   * @param {Object} listElement - List element with static template and dynamic data\n   * @returns {string} Generated HTML\n   */\n  generateListHTML(listElement) {\n    const { static: staticParts, dynamic } = listElement;\n    const items = [];\n\n    for (const dynamicItem of dynamic) {\n      const itemElements = [];\n\n      // Get dynamic indexes in order\n      const dynamicIndexes = Object.keys(dynamicItem)\n        .map((k) => parseInt(k))\n        .sort((a, b) => a - b);\n\n      // Interleave static and dynamic parts\n      let staticIndex = 0;\n      for (const dynIndex of dynamicIndexes) {\n        // Add static part before this dynamic element\n        if (staticIndex < staticParts.length) {\n          itemElements.push(staticParts[staticIndex]);\n          staticIndex++;\n        }\n        // Add dynamic element\n        itemElements.push(String(dynamicItem[dynIndex]));\n      }\n\n      // Add remaining static parts\n      while (staticIndex < staticParts.length) {\n        itemElements.push(staticParts[staticIndex]);\n        staticIndex++;\n      }\n\n      items.push(itemElements.join(''));\n    }\n\n    return items.join('');\n  }\n\n  /**\n   * Get current structure (for debugging/testing)\n   * @returns {Object} Deep copy of current structure\n   */\n  getStructure() {\n    return JSON.parse(JSON.stringify(this.structure));\n  }\n\n  /**\n   * Check if structure has been initialized\n   * @returns {boolean} True if structure contains any components\n   */\n  isInitialized() {\n    return Object.keys(this.structure).length > 0;\n  }\n\n  /**\n   * Get component by ID\n   * @param {string} componentId - Component ID to retrieve\n   * @returns {Object|null} Component structure or null if not found\n   */\n  getComponent(componentId) {\n    return this.structure[componentId] || null;\n  }\n\n  /**\n   * Check if component exists\n   * @param {string} componentId - Component ID to check\n   * @returns {boolean} True if component exists\n   */\n  hasComponent(componentId) {\n    return componentId in this.structure;\n  }\n\n  /**\n   * Get all component IDs\n   * @returns {string[]} Array of all component IDs\n   */\n  getComponentIds() {\n    return Object.keys(this.structure);\n  }\n\n  /**\n   * Clear all structure data\n   */\n  clear() {\n    this.structure = {};\n  }\n\n  /**\n   * Create a patch object that can be sent to arizona.js for DOM updating\n   * This is used by the worker to send structured data to the main thread\n   * @param {string} statefulId - Stateful ID to render (defaults to 'root')\n   * @returns {Object} Patch object with statefulId and HTML\n   */\n  createPatch(statefulId = 'root') {\n    return {\n      type: 'html_patch',\n      statefulId: statefulId,\n      html: this.generateHTML(statefulId),\n      timestamp: Date.now(),\n    };\n  }\n\n  /**\n   * Create an initial render patch (used on first load)\n   * @param {string} statefulId - Stateful ID to render (defaults to 'root')\n   * @returns {Object} Initial render patch object\n   */\n  createInitialPatch(statefulId = 'root') {\n    return {\n      type: 'initial_render',\n      statefulId: statefulId,\n      html: this.generateHTML(statefulId),\n      structure: this.getStructure(),\n      timestamp: Date.now(),\n    };\n  }\n\n  /**\n   * Validate a hierarchical structure format\n   * @param {Object} structure - Structure to validate\n   * @returns {boolean} True if structure is valid\n   */\n  static validateStructure(structure) {\n    if (!structure || typeof structure !== 'object') {\n      return false;\n    }\n\n    for (const [componentId, component] of Object.entries(structure)) {\n      if (!component || typeof component !== 'object') {\n        return false;\n      }\n\n      // Check that component has numeric indexes\n      const indexes = Object.keys(component);\n      for (const index of indexes) {\n        if (isNaN(parseInt(index))) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate diff changes format\n   * @param {Array} changes - Changes to validate\n   * @returns {boolean} True if changes format is valid\n   */\n  static validateDiff(changes) {\n    if (!Array.isArray(changes)) {\n      return false;\n    }\n\n    for (const change of changes) {\n      if (!Array.isArray(change) || change.length !== 2) {\n        return false;\n      }\n\n      const [statefulId, elementChanges] = change;\n      if (typeof statefulId !== 'string' || !Array.isArray(elementChanges)) {\n        return false;\n      }\n\n      for (const elementChange of elementChanges) {\n        if (!Array.isArray(elementChange) || elementChange.length !== 2) {\n          return false;\n        }\n\n        const [elementIndex] = elementChange;\n        if (isNaN(parseInt(elementIndex))) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n}\n\n/**\n * Utility functions for working with hierarchical structures\n */\nexport const ArizonaHierarchicalUtils = {\n  /**\n   * Deep clone a structure\n   * @param {Object} structure - Structure to clone\n   * @returns {Object} Deep cloned structure\n   */\n  cloneStructure(structure) {\n    return JSON.parse(JSON.stringify(structure));\n  },\n\n  /**\n   * Merge two structures (second structure wins on conflicts)\n   * @param {Object} base - Base structure\n   * @param {Object} overlay - Overlay structure\n   * @returns {Object} Merged structure\n   */\n  mergeStructures(base, overlay) {\n    const merged = this.cloneStructure(base);\n\n    for (const [componentId, component] of Object.entries(overlay)) {\n      merged[componentId] = { ...merged[componentId], ...component };\n    }\n\n    return merged;\n  },\n\n  /**\n   * Extract all text content from a structure\n   * @param {Object} structure - Structure to extract text from\n   * @returns {string} Extracted text content\n   */\n  extractTextContent(structure) {\n    const client = new ArizonaHierarchical();\n    client.initialize(structure);\n    const html = client.generateHTML();\n\n    // Simple HTML tag removal for text extraction\n    return html.replace(/<[^>]*>/g, '').trim();\n  },\n\n  /**\n   * Get statistics about a structure\n   * @param {Object} structure - Structure to analyze\n   * @returns {Object} Statistics object\n   */\n  getStructureStats(structure) {\n    let componentCount = 0;\n    let elementCount = 0;\n    let statefulRefs = 0;\n    let statelessComponents = 0;\n    let listComponents = 0;\n\n    for (const [componentId, component] of Object.entries(structure)) {\n      componentCount++;\n\n      for (const element of Object.values(component)) {\n        elementCount++;\n\n        if (element && typeof element === 'object') {\n          if (element.type === 'stateful') {\n            statefulRefs++;\n          } else if (element.type === 'stateless') {\n            statelessComponents++;\n          } else if (element.type === 'list') {\n            listComponents++;\n          }\n        }\n      }\n    }\n\n    return {\n      componentCount,\n      elementCount,\n      statefulRefs,\n      statelessComponents,\n      listComponents,\n    };\n  },\n};\n\n/**\n * Default export for convenience\n */\nexport default ArizonaHierarchical;\n", "// Import ArizonaHierarchical for client-side structure management\nimport ArizonaHierarchical from './arizona-hierarchical.js';\n\n// Arizona WebWorker for WebSocket connection with hierarchical rendering\nclass ArizonaWebSocketWorker {\n  constructor() {\n    this.socket = null;\n    this.connected = false;\n    this.messageQueue = [];\n    this.hierarchical = new ArizonaHierarchical();\n\n    self.onmessage = (event) => {\n      const { type, data } = event.data;\n\n      switch (type) {\n        case 'connect':\n          this.connect(data.url);\n          break;\n        case 'send':\n          this.sendMessage(data);\n          break;\n        case 'disconnect':\n          this.disconnect();\n          break;\n      }\n    };\n  }\n\n  connect(url) {\n    if (this.connected) return;\n\n    this.socket = new WebSocket(url);\n\n    this.socket.onopen = () => {\n      this.connected = true;\n      this.postMessage({ type: 'status', data: { status: 'connected' } });\n      this.flushMessageQueue();\n    };\n\n    this.socket.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      this.handleWebSocketMessage(message);\n    };\n\n    this.socket.onclose = () => {\n      this.connected = false;\n      this.postMessage({ type: 'status', data: { status: 'disconnected' } });\n    };\n\n    this.socket.onerror = (error) => {\n      this.postMessage({ type: 'error', data: { error: error.toString() } });\n    };\n  }\n\n  sendMessage(data) {\n    const message = JSON.stringify(data);\n\n    if (this.connected && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(message);\n    } else {\n      this.messageQueue.push(message);\n    }\n  }\n\n  flushMessageQueue() {\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue.shift();\n      if (this.socket.readyState === WebSocket.OPEN) {\n        this.socket.send(message);\n      } else {\n        this.messageQueue.unshift(message);\n        break;\n      }\n    }\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.connected = false;\n    this.hierarchical.clear();\n  }\n\n  handleWebSocketMessage(message) {\n    try {\n      switch (message.type) {\n        case 'initial_render':\n          this.handleInitialRender(message);\n          break;\n        case 'diff':\n          this.handleDiff(message);\n          break;\n        default:\n          // Pass through other message types unchanged\n          this.postMessage({ type: 'message', data: message });\n          break;\n      }\n    } catch (error) {\n      console.error('[Arizona Worker] Error handling message:', error);\n      this.postMessage({\n        type: 'error',\n        data: { error: `Message handling failed: ${error.message}` },\n      });\n    }\n  }\n\n  handleInitialRender(message) {\n    // Validate structure format\n    if (!ArizonaHierarchical.validateStructure(message.structure)) {\n      throw new Error('Invalid hierarchical structure format');\n    }\n\n    // Initialize hierarchical structure\n    this.hierarchical.initialize(message.structure);\n\n    // Create initial render patch\n    const patch = this.hierarchical.createInitialPatch();\n\n    // Send to main thread for DOM application\n    this.postMessage({\n      type: 'html_patch',\n      data: {\n        patch: patch,\n        isInitial: true,\n      },\n    });\n\n    console.log('[Arizona Worker] Initial render processed');\n  }\n\n  handleDiff(message) {\n    // Validate diff format\n    if (!ArizonaHierarchical.validateDiff(message.changes)) {\n      throw new Error('Invalid diff changes format');\n    }\n\n    if (!this.hierarchical.isInitialized()) {\n      throw new Error('Hierarchical structure not initialized');\n    }\n\n    // Apply diff to hierarchical structure\n    this.hierarchical.applyDiff(message.changes);\n\n    // Create HTML patch\n    const patch = this.hierarchical.createPatch();\n\n    // Send to main thread for DOM application\n    this.postMessage({\n      type: 'html_patch',\n      data: {\n        patch: patch,\n        isInitial: false,\n      },\n    });\n\n    console.log('[Arizona Worker] Diff applied and patch sent');\n  }\n\n  getHierarchicalState() {\n    return {\n      initialized: this.hierarchical.isInitialized(),\n      componentIds: this.hierarchical.getComponentIds(),\n      structure: this.hierarchical.getStructure(),\n    };\n  }\n\n  postMessage(data) {\n    self.postMessage(data);\n  }\n}\n\nnew ArizonaWebSocketWorker();\n"],
  "mappings": "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",
  "names": ["ArizonaHierarchical", "structure", "changes", "statefulId", "elementChanges", "elementIndex", "newValue", "componentId", "component", "elements", "sortedIndexes", "k", "a", "b", "index", "element", "listElement", "staticParts", "dynamic", "items", "dynamicItem", "itemElements", "dynamicIndexes", "staticIndex", "dynIndex", "indexes", "change", "elementChange", "arizona_hierarchical_default", "ArizonaHierarchical", "ArizonaWebSocketWorker", "arizona_hierarchical_default", "event", "type", "data", "url", "message", "error", "patch"]
}
