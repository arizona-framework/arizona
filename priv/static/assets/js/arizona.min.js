/*! Arizona Framework Client v0.2.0 | Apache-2.0 License */
const ee = '/*! Arizona Framework Client v0.2.0 | Apache-2.0 License */(function(){"use strict";class a{constructor(){this.structure=new Map}initialize(t){this.structure=new Map(Object.entries(JSON.parse(JSON.stringify(t))))}applyDiff(t,e){if(e?.type==="stateful"){this.structure.set(e.id,e);return}if(!this.structure.has(t)){const s=String(t).replace(/\\r|\\n/g,"");console.warn(`[Arizona] StatefulId \'${s}\' not found in structure`)}for(const[s,i]of e)if(i&&typeof i=="object"&&i.type)this.structure.get(t).dynamic[s-1]=i;else if(Array.isArray(i)){const r=this.structure.get(t).dynamic[s-1];r&&r.type==="list"?this.structure.get(t).dynamic[s-1].dynamic=i:r&&r.type==="stateless"?i.forEach(([h,o])=>{this.structure.get(t).dynamic[s-1].dynamic[h-1]=o}):this.structure.get(t).dynamic[s-1]=i}else this.structure.get(t).dynamic[s-1]=i}generateStatefulHTML(t){const e=this.structure.get(t);if(!e){const s=String(t).replace(/\\r|\\n/g,"");console.warn(`[Arizona] StatefulId \'${s}\' not found in structure`)}return this.zipStaticDynamic(e.static,e.dynamic)}generateStatelessHTML(t){return this.zipStaticDynamic(t.static,t.dynamic)}generateListHTML(t){const{static:e,dynamic:s}=t;return s.reduce((i,r)=>i+this.zipStaticDynamic(e,r),"")}zipStaticDynamic(t,e){const s=[],i=Math.max(t.length,e.length);for(let r=0;r<i;r++)r<t.length&&s.push(t[r]),r<e.length&&s.push(this.normalizeDynamicElement(e[r]));return s.join("")}normalizeDynamicElement(t){return typeof t=="string"?t:t&&t.type==="stateful"?this.generateStatefulHTML(t.id):t&&t.type==="stateless"?this.generateStatelessHTML(t):t&&t.type==="list"?this.generateListHTML(t):Array.isArray(t)?this.flattenIoData(t):String(t)}flattenIoData(t){return typeof t=="string"?t:typeof t=="number"?String(t):Array.isArray(t)?t.map(e=>this.flattenIoData(e)).join(""):t&&typeof t=="object"?t.type==="stateful"?this.generateStatefulHTML(t.id):t.type==="stateless"?this.generateStatelessHTML(t):t.type==="list"?this.generateListHTML(t):String(t):String(t||"")}getStructure(){return JSON.parse(JSON.stringify(Object.fromEntries(this.structure)))}isInitialized(){return this.structure.size>0}getComponentIds(){return Array.from(this.structure.keys())}clear(){this.structure=new Map}createPatch(t){return{type:"html_patch",statefulId:t,html:this.generateStatefulHTML(t)}}}class n{constructor(){this.socket=null,this.connected=!1,this.messageQueue=[],this.hierarchical=new a,self.onmessage=t=>{const{type:e,data:s}=t.data;switch(e){case"connect":this.connect(s.url);break;case"send":this.sendMessage(s);break;case"disconnect":this.disconnect();break}}}connect(t){this.connected||(this.socket=new WebSocket(t),this.socket.onopen=()=>{this.connected=!0,this.postMessage({type:"status",data:{status:"connected"}}),this.flushMessageQueue()},this.socket.onmessage=e=>{const s=JSON.parse(e.data);this.handleWebSocketMessage(s)},this.socket.onclose=()=>{this.connected=!1,this.postMessage({type:"status",data:{status:"disconnected"}})},this.socket.onerror=e=>{this.postMessage({type:"error",data:{error:e.toString()}})})}sendMessage(t){const e=JSON.stringify(t);this.connected&&this.socket.readyState===WebSocket.OPEN?this.socket.send(e):this.messageQueue.push(e)}flushMessageQueue(){for(;this.messageQueue.length>0;){const t=this.messageQueue.shift();if(this.socket.readyState===WebSocket.OPEN)this.socket.send(t);else{this.messageQueue.unshift(t);break}}}disconnect(){this.socket&&(this.socket.close(),this.socket=null),this.connected=!1,this.hierarchical.clear()}handleWebSocketMessage(t){try{switch(t.type){case"initial_render":this.handleInitialRender(t);break;case"diff":this.handleDiff(t);break;case"reload":this.handleReload(t);break;case"dispatch_to":this.handleDispatchTo(t);break;case"redirect":this.handleRedirect(t);break;default:this.handleUnknownMessage(t)}}catch(e){this.postMessage({type:"error",data:{error:`Message handling failed: ${e.message}`}})}}handleInitialRender(t){this.hierarchical.initialize(t.structure)}handleDiff(t){if(!this.hierarchical.isInitialized())throw new Error("Hierarchical structure not initialized");this.hierarchical.applyDiff(t.stateful_id,t.changes);const e=this.hierarchical.createPatch(t.stateful_id);this.postMessage({type:"html_patch",data:{patch:e}})}handleReload(t){this.postMessage({type:"reload",data:t})}handleDispatchTo(t){this.postMessage({type:"dispatch_to",data:{selector:t.selector,event:t.event,options:{detail:t.data}}})}handleRedirect(t){this.postMessage({type:"redirect",data:{url:t.url,target:t.target}})}handleUnknownMessage(t){this.postMessage(t)}postMessage(t){self.postMessage(t)}}new n})();\n//# sourceMappingURL=arizona-worker.min.js.map\n', J = typeof self < "u" && self.Blob && new Blob(["(self.URL || self.webkitURL).revokeObjectURL(self.location.href);", ee], { type: "text/javascript;charset=utf-8" });
function ce(i) {
  let e;
  try {
    if (e = J && (self.URL || self.webkitURL).createObjectURL(J), !e) throw "";
    const t = new Worker(e, {
      name: i?.name
    });
    return t.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), t;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(ee),
      {
        name: i?.name
      }
    );
  }
}
var K = 11;
function oe(i, e) {
  var t = e.attributes, s, r, c, h, p;
  if (!(e.nodeType === K || i.nodeType === K)) {
    for (var w = t.length - 1; w >= 0; w--)
      s = t[w], r = s.name, c = s.namespaceURI, h = s.value, c ? (r = s.localName || r, p = i.getAttributeNS(c, r), p !== h && (s.prefix === "xmlns" && (r = s.name), i.setAttributeNS(c, r, h))) : (p = i.getAttribute(r), p !== h && i.setAttribute(r, h));
    for (var A = i.attributes, L = A.length - 1; L >= 0; L--)
      s = A[L], r = s.name, c = s.namespaceURI, c ? (r = s.localName || r, e.hasAttributeNS(c, r) || i.removeAttributeNS(c, r)) : e.hasAttribute(r) || i.removeAttribute(r);
  }
}
var H, le = "http://www.w3.org/1999/xhtml", f = typeof document > "u" ? void 0 : document, he = !!f && "content" in f.createElement("template"), de = !!f && f.createRange && "createContextualFragment" in f.createRange();
function ue(i) {
  var e = f.createElement("template");
  return e.innerHTML = i, e.content.childNodes[0];
}
function fe(i) {
  H || (H = f.createRange(), H.selectNode(f.body));
  var e = H.createContextualFragment(i);
  return e.childNodes[0];
}
function pe(i) {
  var e = f.createElement("body");
  return e.innerHTML = i, e.childNodes[0];
}
function ge(i) {
  return i = i.trim(), he ? ue(i) : de ? fe(i) : pe(i);
}
function _(i, e) {
  var t = i.nodeName, s = e.nodeName, r, c;
  return t === s ? !0 : (r = t.charCodeAt(0), c = s.charCodeAt(0), r <= 90 && c >= 97 ? t === s.toUpperCase() : c <= 90 && r >= 97 ? s === t.toUpperCase() : !1);
}
function ve(i, e) {
  return !e || e === le ? f.createElement(i) : f.createElementNS(e, i);
}
function ye(i, e) {
  for (var t = i.firstChild; t; ) {
    var s = t.nextSibling;
    e.appendChild(t), t = s;
  }
  return e;
}
function j(i, e, t) {
  i[t] !== e[t] && (i[t] = e[t], i[t] ? i.setAttribute(t, "") : i.removeAttribute(t));
}
var X = {
  OPTION: function(i, e) {
    var t = i.parentNode;
    if (t) {
      var s = t.nodeName.toUpperCase();
      s === "OPTGROUP" && (t = t.parentNode, s = t && t.nodeName.toUpperCase()), s === "SELECT" && !t.hasAttribute("multiple") && (i.hasAttribute("selected") && !e.selected && (i.setAttribute("selected", "selected"), i.removeAttribute("selected")), t.selectedIndex = -1);
    }
    j(i, e, "selected");
  },
  /**
   * The "value" attribute is special for the <input> element since it sets
   * the initial value. Changing the "value" attribute without changing the
   * "value" property will have no effect since it is only used to the set the
   * initial value.  Similar for the "checked" attribute, and "disabled".
   */
  INPUT: function(i, e) {
    j(i, e, "checked"), j(i, e, "disabled"), i.value !== e.value && (i.value = e.value), e.hasAttribute("value") || i.removeAttribute("value");
  },
  TEXTAREA: function(i, e) {
    var t = e.value;
    i.value !== t && (i.value = t);
    var s = i.firstChild;
    if (s) {
      var r = s.nodeValue;
      if (r == t || !t && r == i.placeholder)
        return;
      s.nodeValue = t;
    }
  },
  SELECT: function(i, e) {
    if (!e.hasAttribute("multiple")) {
      for (var t = -1, s = 0, r = i.firstChild, c, h; r; )
        if (h = r.nodeName && r.nodeName.toUpperCase(), h === "OPTGROUP")
          c = r, r = c.firstChild, r || (r = c.nextSibling, c = null);
        else {
          if (h === "OPTION") {
            if (r.hasAttribute("selected")) {
              t = s;
              break;
            }
            s++;
          }
          r = r.nextSibling, !r && c && (r = c.nextSibling, c = null);
        }
      i.selectedIndex = t;
    }
  }
}, M = 1, q = 11, Y = 3, Z = 8;
function b() {
}
function be(i) {
  if (i)
    return i.getAttribute && i.getAttribute("id") || i.id;
}
function we(i) {
  return function(t, s, r) {
    if (r || (r = {}), typeof s == "string")
      if (t.nodeName === "#document" || t.nodeName === "HTML" || t.nodeName === "BODY") {
        var c = s;
        s = f.createElement("html"), s.innerHTML = c;
      } else
        s = ge(s);
    else s.nodeType === q && (s = s.firstElementChild);
    var h = r.getNodeKey || be, p = r.onBeforeNodeAdded || b, w = r.onNodeAdded || b, A = r.onBeforeElUpdated || b, L = r.onElUpdated || b, te = r.onBeforeNodeDiscarded || b, U = r.onNodeDiscarded || b, se = r.onBeforeElChildrenUpdated || b, re = r.skipFromChildren || b, B = r.addChild || function(n, a) {
      return n.appendChild(a);
    }, C = r.childrenOnly === !0, m = /* @__PURE__ */ Object.create(null), R = [];
    function O(n) {
      R.push(n);
    }
    function V(n, a) {
      if (n.nodeType === M)
        for (var d = n.firstChild; d; ) {
          var o = void 0;
          a && (o = h(d)) ? O(o) : (U(d), d.firstChild && V(d, a)), d = d.nextSibling;
        }
    }
    function D(n, a, d) {
      te(n) !== !1 && (a && a.removeChild(n), U(n), V(n, d));
    }
    function x(n) {
      if (n.nodeType === M || n.nodeType === q)
        for (var a = n.firstChild; a; ) {
          var d = h(a);
          d && (m[d] = a), x(a), a = a.nextSibling;
        }
    }
    x(t);
    function I(n) {
      w(n);
      for (var a = n.firstChild; a; ) {
        var d = a.nextSibling, o = h(a);
        if (o) {
          var l = m[o];
          l && _(a, l) ? (a.parentNode.replaceChild(l, a), N(l, a)) : I(a);
        } else
          I(a);
        a = d;
      }
    }
    function ie(n, a, d) {
      for (; a; ) {
        var o = a.nextSibling;
        (d = h(a)) ? O(d) : D(
          a,
          n,
          !0
          /* skip keyed nodes */
        ), a = o;
      }
    }
    function N(n, a, d) {
      var o = h(a);
      if (o && delete m[o], !d) {
        var l = A(n, a);
        if (l === !1 || (l instanceof HTMLElement && (n = l, x(n)), i(n, a), L(n), se(n, a) === !1))
          return;
      }
      n.nodeName !== "TEXTAREA" ? ne(n, a) : X.TEXTAREA(n, a);
    }
    function ne(n, a) {
      var d = re(n, a), o = a.firstChild, l = n.firstChild, S, g, k, z, v;
      e: for (; o; ) {
        for (z = o.nextSibling, S = h(o); !d && l; ) {
          if (k = l.nextSibling, o.isSameNode && o.isSameNode(l)) {
            o = z, l = k;
            continue e;
          }
          g = h(l);
          var $ = l.nodeType, y = void 0;
          if ($ === o.nodeType && ($ === M ? (S ? S !== g && ((v = m[S]) ? k === v ? y = !1 : (n.insertBefore(v, l), g ? O(g) : D(
            l,
            n,
            !0
            /* skip keyed nodes */
          ), l = v, g = h(l)) : y = !1) : g && (y = !1), y = y !== !1 && _(l, o), y && N(l, o)) : ($ === Y || $ == Z) && (y = !0, l.nodeValue !== o.nodeValue && (l.nodeValue = o.nodeValue))), y) {
            o = z, l = k;
            continue e;
          }
          g ? O(g) : D(
            l,
            n,
            !0
            /* skip keyed nodes */
          ), l = k;
        }
        if (S && (v = m[S]) && _(v, o))
          d || B(n, v), N(v, o);
        else {
          var F = p(o);
          F !== !1 && (F && (o = F), o.actualize && (o = o.actualize(n.ownerDocument || f)), B(n, o), I(o));
        }
        o = z, l = k;
      }
      ie(n, l, g);
      var G = X[n.nodeName];
      G && G(n, a);
    }
    var u = t, E = u.nodeType, Q = s.nodeType;
    if (!C) {
      if (E === M)
        Q === M ? _(t, s) || (U(t), u = ye(t, ve(s.nodeName, s.namespaceURI))) : u = s;
      else if (E === Y || E === Z) {
        if (Q === E)
          return u.nodeValue !== s.nodeValue && (u.nodeValue = s.nodeValue), u;
        u = s;
      }
    }
    if (u === s)
      U(t);
    else {
      if (s.isSameNode && s.isSameNode(u))
        return;
      if (N(u, s, C), R)
        for (var P = 0, ae = R.length; P < ae; P++) {
          var W = m[R[P]];
          W && D(W, W.parentNode, !1);
        }
    }
    return !C && u !== t && t.parentNode && (u.actualize && (u = u.actualize(t.ownerDocument || f)), t.parentNode.replaceChild(u, t)), u;
  };
}
var me = we(oe);
const T = {
  silent: -1,
  error: 3,
  warning: 4,
  info: 6,
  debug: 7
};
class Se {
  /**
   * Creates a new Arizona client instance
   * @param {ArizonaClientOptions} [opts={}] - Client configuration options
   */
  constructor(e = {}) {
    this.worker = null, this.connected = !1, this.logLevel = T[e.logLevel] ?? T.silent, this.eventListeners = /* @__PURE__ */ new Map(), this.scopedEventListeners = /* @__PURE__ */ new Map();
  }
  /**
   * Initialize worker if not already created
   * @private
   * @returns {void}
   */
  initializeWorker() {
    this.worker || (this.worker = new ce(), this.worker.onmessage = (e) => {
      this.handleWorkerMessage(e.data);
    });
  }
  /**
   * Connect to the Arizona WebSocket server
   * @param {string} websocketEndpoint - WebSocket endpoint path
   * @returns {void}
   */
  connect(e) {
    if (this.connected) return;
    this.initializeWorker();
    const t = window.location.protocol === "https:" ? "wss:" : "ws:", s = window.location.host, r = window.location.pathname, c = window.location.search, h = encodeURIComponent(r), p = c ? encodeURIComponent(c.substring(1)) : "", w = `${t}//${s}${e}?path=${h}&qs=${p}`;
    this.worker.postMessage({
      type: "connect",
      data: { url: w }
    });
  }
  /**
   * Push an event to the Arizona server
   * @param {string} event - Event name
   * @param {EventParams} [params={}] - Event parameters
   * @returns {void}
   */
  pushEvent(e, t = {}) {
    this.connected && this.worker.postMessage({
      type: "send",
      data: {
        type: "event",
        event: e,
        params: t
      }
    });
  }
  /**
   * Push an event to a specific stateful component
   * @param {string} statefulId - Target stateful component ID
   * @param {string} event - Event name
   * @param {EventParams} [params={}] - Event parameters
   * @returns {void}
   */
  pushEventTo(e, t, s = {}) {
    this.connected && this.worker.postMessage({
      type: "send",
      data: {
        type: "event",
        stateful_id: e,
        event: t,
        params: s
      }
    });
  }
  /**
   * Disconnect from the Arizona WebSocket server
   * @returns {void}
   */
  disconnect() {
    this.worker && (this.worker.terminate(), this.worker = null), this.connected = !1;
  }
  /**
   * Handle messages from the worker thread
   * @private
   * @param {Object} message - Worker message
   * @returns {void}
   */
  handleWorkerMessage(e) {
    const { type: t, data: s } = e;
    try {
      switch (t) {
        case "status":
          this.handleStatus(s);
          break;
        case "initial_render":
          break;
        case "html_patch":
          this.handleHtmlPatch(s);
          break;
        case "error":
          this.handleWorkerError(s);
          break;
        case "reload":
          this.handleReload(s);
          break;
        case "dispatch_to":
          this.handleDispatchTo(s);
          break;
        case "redirect":
          this.handleRedirect(s);
          break;
        default:
          this.handleUnknownMessage(e);
      }
    } catch (r) {
      this.error("Error handling worker message:", r);
    }
  }
  handleStatus(e) {
    e.status === "connected" ? (this.connected = !0, this.info("Connected to WebSocket"), this.emit("connected", e)) : e.status === "disconnected" && (this.connected = !1, this.info("Disconnected from WebSocket"), this.emit("disconnected", e));
  }
  handleHtmlPatch(e) {
    this.debug("Applying HTML patch"), this.applyHtmlPatch(e.patch);
  }
  applyHtmlPatch(e) {
    const t = document.getElementById(e.statefulId);
    if (!t) {
      this.warning(`Target element not found: ${e.statefulId}`);
      return;
    }
    try {
      me(t, e.html, {
        onBeforeElUpdated(s, r) {
          return r.dataset?.arizonaUpdate === "false" ? !1 : !s.isEqualNode(r);
        }
      }), this.debug("Patch applied successfully"), t.dispatchEvent(
        new CustomEvent("arizona:patched", {
          detail: { patch: e }
        })
      );
    } catch (s) {
      this.error("Error applying HTML patch:", s);
    }
  }
  handleWorkerError(e) {
    this.error("Worker Error:", e.error), this.emit("error", e);
  }
  handleReload(e) {
    switch (e.file_type) {
      case "css":
        this.info("CSS file changed. Refreshing stylesheets without page reload..."), document.querySelectorAll('link[rel="stylesheet"]').forEach((t) => {
          const s = t.href.split("?")[0];
          t.href = `${s}?t=${Date.now()}`;
        });
        break;
      default:
        this.info(`${e.file_type || "File"} changed. Reloading page...`), window.location.reload();
    }
  }
  handleDispatchTo(e) {
    this.debug("WebSocket dispatch to:", e);
    const t = e.selector.replace(/^[#.]/, "");
    this.emitFor(t, e.event, e.options?.detail);
  }
  handleRedirect(e) {
    this.info("Redirecting to:", e.url), window.open(e.url, e.options?.target, e.options?.window_features);
  }
  handleUnknownMessage(e) {
    this.warning("Unknown worker message:", e);
  }
  /**
   * Check if client is connected to server
   * @returns {boolean} True if connected
   */
  isConnected() {
    return this.connected;
  }
  // Logging methods aligned with Erlang logger levels
  /**
   * Log error message (always shown)
   * @param {string} message - Error message
   * @param {...*} args - Additional arguments
   * @returns {void}
   */
  error(e, ...t) {
    console.error(`[Arizona] ${e}`, ...t);
  }
  /**
   * Log warning message (shown if log level allows)
   * @param {string} message - Warning message
   * @param {...*} args - Additional arguments
   * @returns {void}
   */
  warning(e, ...t) {
    this.logLevel >= T.warning && console.warn(`[Arizona] ${e}`, ...t);
  }
  /**
   * Log info message (shown if log level allows)
   * @param {string} message - Info message
   * @param {...*} args - Additional arguments
   * @returns {void}
   */
  info(e, ...t) {
    this.logLevel >= T.info && console.log(`[Arizona] ${e}`, ...t);
  }
  /**
   * Log debug message (shown if log level allows)
   * @param {string} message - Debug message
   * @param {...*} args - Additional arguments
   * @returns {void}
   */
  debug(e, ...t) {
    this.logLevel >= T.debug && console.log(`[Arizona] ${e}`, ...t);
  }
  /**
   * Subscribe to an Arizona event
   * @param {string} event - Event name (e.g., 'connected', 'disconnected')
   * @param {Function} callback - Callback function to invoke when event occurs
   * @returns {Function} Unsubscribe function
   */
  on(e, t) {
    return typeof t != "function" ? (this.error(`on: callback must be a function, got ${typeof t}`), () => {
    }) : (this.eventListeners.has(e) || this.eventListeners.set(e, /* @__PURE__ */ new Set()), this.eventListeners.get(e).add(t), this.debug(`Subscribed to event: ${e}`), () => this.off(e, t));
  }
  /**
   * Unsubscribe from an Arizona event
   * @param {string} event - Event name
   * @param {Function} callback - Callback function to remove
   * @returns {void}
   */
  off(e, t) {
    const s = this.eventListeners.get(e);
    s && (s.delete(t), this.debug(`Unsubscribed from event: ${e}`), s.size === 0 && this.eventListeners.delete(e));
  }
  /**
   * Emit an Arizona event to all subscribed listeners
   * @private
   * @param {string} event - Event name
   * @param {*} data - Event data to pass to listeners
   * @returns {void}
   */
  emit(e, t) {
    const s = this.eventListeners.get(e);
    s && s.forEach((r) => {
      try {
        r(t);
      } catch (c) {
        this.error(`Error in event listener for '${e}':`, c);
      }
    });
  }
  /**
   * Subscribe to a component-scoped Arizona event
   * @param {string|HTMLElement} target - Target element ID or element reference
   * @param {string} event - Event name (e.g., 'incr', 'update')
   * @param {Function} callback - Callback function to invoke when event occurs
   * @returns {Function} Unsubscribe function
   */
  onFor(e, t, s) {
    if (typeof s != "function")
      return this.error(`onFor: callback must be a function, got ${typeof s}`), () => {
      };
    const r = typeof e == "string" ? e : e?.id;
    if (!r)
      return this.error("onFor: target must be a string ID or element with id attribute"), () => {
      };
    this.scopedEventListeners.has(r) || this.scopedEventListeners.set(r, /* @__PURE__ */ new Map());
    const c = this.scopedEventListeners.get(r);
    return c.has(t) || c.set(t, /* @__PURE__ */ new Set()), c.get(t).add(s), this.debug(`Subscribed to scoped event: ${r}:${t}`), () => this.offFor(r, t, s);
  }
  /**
   * Unsubscribe from a component-scoped Arizona event
   * @param {string} targetId - Target element ID
   * @param {string} event - Event name
   * @param {Function} callback - Callback function to remove
   * @returns {void}
   */
  offFor(e, t, s) {
    const r = this.scopedEventListeners.get(e);
    if (r) {
      const c = r.get(t);
      c && (c.delete(s), this.debug(`Unsubscribed from scoped event: ${e}:${t}`), c.size === 0 && r.delete(t), r.size === 0 && this.scopedEventListeners.delete(e));
    }
  }
  /**
   * Emit a component-scoped event to all subscribed listeners
   * @private
   * @param {string} targetId - Target element ID
   * @param {string} event - Event name
   * @param {*} data - Event data to pass to listeners
   * @returns {void}
   */
  emitFor(e, t, s) {
    const r = this.scopedEventListeners.get(e);
    if (r) {
      const c = r.get(t);
      c && c.forEach((h) => {
        try {
          h(s);
        } catch (p) {
          this.error(`Error in scoped event listener for '${e}:${t}':`, p);
        }
      });
    }
  }
}
export {
  Se as default
};
//# sourceMappingURL=arizona.min.js.map
