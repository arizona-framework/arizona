/*! Arizona Framework Client v0.2.0 | Apache-2.0 License */
const Z = '/*! Arizona Framework Client v0.2.0 | Apache-2.0 License */(function(){"use strict";class n{constructor(){this.structure=new Map}initialize(t){this.structure=new Map(Object.entries(JSON.parse(JSON.stringify(t))))}applyDiff(t,s){if(s?.type==="stateful"){this.structure.set(s.id,s);return}if(!this.structure.has(t)){const i=String(t).replace(/\\r|\\n/g,"");console.warn(`[Arizona] StatefulId \'${i}\' not found in structure`)}const e=this.structure.get(t);console.log("[Arizona] Applying diff to",t),console.log("[Arizona] Changes:",s),console.log("[Arizona] Component dynamic before:",JSON.parse(JSON.stringify(e.dynamic)));for(const[i,r]of s)console.log("[Arizona] Applying change - index:",i,"value:",r),this.applyDiffValue(e.dynamic,i-1,r);console.log("[Arizona] Component dynamic after:",JSON.parse(JSON.stringify(e.dynamic)))}applyDiffValue(t,s,e){const i=t[s];if(i&&typeof i=="object"&&i.type==="stateful"){if(e&&typeof e=="object"&&e.type){this.structure.delete(i.id),t[s]=e,e.type==="stateful"&&e.static&&e.dynamic&&(console.log("[Arizona] Replacing stateful component in map:",e.id),this.structure.set(e.id,e));return}if(Array.isArray(e)){const r=this.structure.get(i.id);if(!r){const a=String(i.id).replace(/\\r|\\n/g,"");console.warn(`[Arizona] Nested stateful component \'${a}\' not found in structure`);return}e.forEach(([a,h])=>{this.applyDiffValue(r.dynamic,a-1,h)});return}this.structure.delete(i.id),t[s]=e;return}if(e&&typeof e=="object"&&e.type){t[s]=e,e.type==="stateful"&&e.static&&e.dynamic?(console.log("[Arizona] Adding full stateful structure to map:",e.id),this.structure.set(e.id,e)):e.type==="stateful"&&console.log("[Arizona] Skipping stateful reference (no static/dynamic):",e.id);return}if(Array.isArray(e)){if(i&&i.type==="list"){i.dynamic=e;return}if(i&&i.type==="stateless"){e.forEach(([r,a])=>{this.applyDiffValue(i.dynamic,r-1,a)});return}t[s]=e;return}t[s]=e}generateStatefulHTML(t){console.log("[Arizona] generateStatefulHTML for",t);const s=this.structure.get(t);if(!s){const i=String(t).replace(/\\r|\\n/g,"");throw console.warn(`[Arizona] StatefulId \'${i}\' not found in structure`),new Error(`Component ${i} not found`)}console.log("[Arizona] Structure found, generating HTML...");const e=this.zipStaticDynamic(s.static,s.dynamic);return console.log("[Arizona] HTML generated for",t,"length:",e.length),e}generateStatelessHTML(t){return this.zipStaticDynamic(t.static,t.dynamic)}generateListHTML(t){const{static:s,dynamic:e}=t;return e.reduce((i,r)=>i+this.zipStaticDynamic(s,r),"")}zipStaticDynamic(t,s){const e=[],i=Math.max(t.length,s.length);for(let r=0;r<i;r++)r<t.length&&e.push(t[r]),r<s.length&&e.push(this.normalizeDynamicElement(s[r]));return e.join("")}normalizeDynamicElement(t){return typeof t=="string"?t:t&&t.type==="stateful"?this.generateStatefulHTML(t.id):t&&t.type==="stateless"?this.generateStatelessHTML(t):t&&t.type==="list"?this.generateListHTML(t):Array.isArray(t)?this.flattenIoData(t):String(t)}flattenIoData(t){return typeof t=="string"?t:typeof t=="number"?String(t):Array.isArray(t)?t.map(s=>this.flattenIoData(s)).join(""):t&&typeof t=="object"?t.type==="stateful"?this.generateStatefulHTML(t.id):t.type==="stateless"?this.generateStatelessHTML(t):t.type==="list"?this.generateListHTML(t):String(t):String(t||"")}getStructure(){return JSON.parse(JSON.stringify(Object.fromEntries(this.structure)))}isInitialized(){return this.structure.size>0}getComponentIds(){return Array.from(this.structure.keys())}clear(){this.structure=new Map}createPatch(t){console.log("[Arizona] createPatch called for",t);const s=this.generateStatefulHTML(t);return console.log("[Arizona] HTML generated, length:",s.length),{type:"html_patch",statefulId:t,html:s}}}class o{constructor(){this.socket=null,this.connected=!1,this.messageQueue=[],this.hierarchical=new n,self.onmessage=t=>{const{type:s,data:e}=t.data;switch(s){case"connect":this.connect(e.url);break;case"send":this.sendMessage(e);break;case"disconnect":this.disconnect();break}}}connect(t){this.connected||(this.socket=new WebSocket(t),this.socket.onopen=()=>{this.connected=!0,this.postMessage({type:"status",data:{status:"connected"}}),this.flushMessageQueue()},this.socket.onmessage=s=>{const e=JSON.parse(s.data);this.handleWebSocketMessage(e)},this.socket.onclose=()=>{this.connected=!1,this.postMessage({type:"status",data:{status:"disconnected"}})},this.socket.onerror=s=>{this.postMessage({type:"error",data:{error:s.toString()}})})}sendMessage(t){const s=JSON.stringify(t);this.connected&&this.socket.readyState===WebSocket.OPEN?this.socket.send(s):this.messageQueue.push(s)}flushMessageQueue(){for(;this.messageQueue.length>0;){const t=this.messageQueue.shift();if(this.socket.readyState===WebSocket.OPEN)this.socket.send(t);else{this.messageQueue.unshift(t);break}}}disconnect(){this.socket&&(this.socket.close(),this.socket=null),this.connected=!1,this.hierarchical.clear()}handleWebSocketMessage(t){try{switch(t.type){case"initial_render":this.handleInitialRender(t);break;case"diff":this.handleDiff(t);break;case"reload":this.handleReload(t);break;case"dispatch":this.handleDispatch(t);break;case"reply":this.handleReply(t);break;case"redirect":this.handleRedirect(t);break;default:this.handleUnknownMessage(t)}}catch(s){this.postMessage({type:"error",data:{error:`Message handling failed: ${s.message}`}})}}handleInitialRender(t){this.hierarchical.initialize(t.structure)}handleDiff(t){if(!this.hierarchical.isInitialized())throw new Error("Hierarchical structure not initialized");console.log("[Worker] Handling diff for",t.stateful_id),this.hierarchical.applyDiff(t.stateful_id,t.changes),console.log("[Worker] Creating patch for",t.stateful_id);const s=this.hierarchical.createPatch(t.stateful_id);console.log("[Worker] Patch created:",s),this.postMessage({type:"html_patch",data:{patch:s}}),console.log("[Worker] Patch sent to main thread")}handleReload(t){this.postMessage({type:"reload",data:t})}handleDispatch(t){this.postMessage({type:"dispatch",data:t})}handleReply(t){this.postMessage({type:"reply",data:t})}handleRedirect(t){this.postMessage({type:"redirect",data:{url:t.url,target:t.target}})}handleUnknownMessage(t){this.postMessage(t)}postMessage(t){self.postMessage(t)}}new o})();\n//# sourceMappingURL=arizona-worker.min.js.map\n', Q = typeof self < "u" && self.Blob && new Blob(["(self.URL || self.webkitURL).revokeObjectURL(self.location.href);", Z], { type: "text/javascript;charset=utf-8" });
function ae(i) {
  let e;
  try {
    if (e = Q && (self.URL || self.webkitURL).createObjectURL(Q), !e) throw "";
    const t = new Worker(e, {
      name: i?.name
    });
    return t.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), t;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(Z),
      {
        name: i?.name
      }
    );
  }
}
var G = 11;
function oe(i, e) {
  var t = e.attributes, n, r, l, h, g;
  if (!(e.nodeType === G || i.nodeType === G)) {
    for (var p = t.length - 1; p >= 0; p--)
      n = t[p], r = n.name, l = n.namespaceURI, h = n.value, l ? (r = n.localName || r, g = i.getAttributeNS(l, r), g !== h && (n.prefix === "xmlns" && (r = n.name), i.setAttributeNS(l, r, h))) : (g = i.getAttribute(r), g !== h && i.setAttribute(r, h));
    for (var b = i.attributes, M = b.length - 1; M >= 0; M--)
      n = b[M], r = n.name, l = n.namespaceURI, l ? (r = n.localName || r, e.hasAttributeNS(l, r) || i.removeAttributeNS(l, r)) : e.hasAttribute(r) || i.removeAttribute(r);
  }
}
var H, le = "http://www.w3.org/1999/xhtml", f = typeof document > "u" ? void 0 : document, ce = !!f && "content" in f.createElement("template"), he = !!f && f.createRange && "createContextualFragment" in f.createRange();
function de(i) {
  var e = f.createElement("template");
  return e.innerHTML = i, e.content.childNodes[0];
}
function ue(i) {
  H || (H = f.createRange(), H.selectNode(f.body));
  var e = H.createContextualFragment(i);
  return e.childNodes[0];
}
function fe(i) {
  var e = f.createElement("body");
  return e.innerHTML = i, e.childNodes[0];
}
function ge(i) {
  return i = i.trim(), ce ? de(i) : he ? ue(i) : fe(i);
}
function _(i, e) {
  var t = i.nodeName, n = e.nodeName, r, l;
  return t === n ? !0 : (r = t.charCodeAt(0), l = n.charCodeAt(0), r <= 90 && l >= 97 ? t === n.toUpperCase() : l <= 90 && r >= 97 ? n === t.toUpperCase() : !1);
}
function pe(i, e) {
  return !e || e === le ? f.createElement(i) : f.createElementNS(e, i);
}
function ye(i, e) {
  for (var t = i.firstChild; t; ) {
    var n = t.nextSibling;
    e.appendChild(t), t = n;
  }
  return e;
}
function j(i, e, t) {
  i[t] !== e[t] && (i[t] = e[t], i[t] ? i.setAttribute(t, "") : i.removeAttribute(t));
}
var K = {
  OPTION: function(i, e) {
    var t = i.parentNode;
    if (t) {
      var n = t.nodeName.toUpperCase();
      n === "OPTGROUP" && (t = t.parentNode, n = t && t.nodeName.toUpperCase()), n === "SELECT" && !t.hasAttribute("multiple") && (i.hasAttribute("selected") && !e.selected && (i.setAttribute("selected", "selected"), i.removeAttribute("selected")), t.selectedIndex = -1);
    }
    j(i, e, "selected");
  },
  /**
   * The "value" attribute is special for the <input> element since it sets
   * the initial value. Changing the "value" attribute without changing the
   * "value" property will have no effect since it is only used to the set the
   * initial value.  Similar for the "checked" attribute, and "disabled".
   */
  INPUT: function(i, e) {
    j(i, e, "checked"), j(i, e, "disabled"), i.value !== e.value && (i.value = e.value), e.hasAttribute("value") || i.removeAttribute("value");
  },
  TEXTAREA: function(i, e) {
    var t = e.value;
    i.value !== t && (i.value = t);
    var n = i.firstChild;
    if (n) {
      var r = n.nodeValue;
      if (r == t || !t && r == i.placeholder)
        return;
      n.nodeValue = t;
    }
  },
  SELECT: function(i, e) {
    if (!e.hasAttribute("multiple")) {
      for (var t = -1, n = 0, r = i.firstChild, l, h; r; )
        if (h = r.nodeName && r.nodeName.toUpperCase(), h === "OPTGROUP")
          l = r, r = l.firstChild, r || (r = l.nextSibling, l = null);
        else {
          if (h === "OPTION") {
            if (r.hasAttribute("selected")) {
              t = n;
              break;
            }
            n++;
          }
          r = r.nextSibling, !r && l && (r = l.nextSibling, l = null);
        }
      i.selectedIndex = t;
    }
  }
}, T = 1, X = 11, q = 3, Y = 8;
function w() {
}
function ve(i) {
  if (i)
    return i.getAttribute && i.getAttribute("id") || i.id;
}
function me(i) {
  return function(t, n, r) {
    if (r || (r = {}), typeof n == "string")
      if (t.nodeName === "#document" || t.nodeName === "HTML" || t.nodeName === "BODY") {
        var l = n;
        n = f.createElement("html"), n.innerHTML = l;
      } else
        n = ge(n);
    else n.nodeType === X && (n = n.firstElementChild);
    var h = r.getNodeKey || ve, g = r.onBeforeNodeAdded || w, p = r.onNodeAdded || w, b = r.onBeforeElUpdated || w, M = r.onElUpdated || w, ee = r.onBeforeNodeDiscarded || w, L = r.onNodeDiscarded || w, te = r.onBeforeElChildrenUpdated || w, ne = r.skipFromChildren || w, V = r.addChild || function(s, a) {
      return s.appendChild(a);
    }, E = r.childrenOnly === !0, k = /* @__PURE__ */ Object.create(null), R = [];
    function z(s) {
      R.push(s);
    }
    function B(s, a) {
      if (s.nodeType === T)
        for (var d = s.firstChild; d; ) {
          var o = void 0;
          a && (o = h(d)) ? z(o) : (L(d), d.firstChild && B(d, a)), d = d.nextSibling;
        }
    }
    function D(s, a, d) {
      ee(s) !== !1 && (a && a.removeChild(s), L(s), B(s, d));
    }
    function P(s) {
      if (s.nodeType === T || s.nodeType === X)
        for (var a = s.firstChild; a; ) {
          var d = h(a);
          d && (k[d] = a), P(a), a = a.nextSibling;
        }
    }
    P(t);
    function I(s) {
      p(s);
      for (var a = s.firstChild; a; ) {
        var d = a.nextSibling, o = h(a);
        if (o) {
          var c = k[o];
          c && _(a, c) ? (a.parentNode.replaceChild(c, a), N(c, a)) : I(a);
        } else
          I(a);
        a = d;
      }
    }
    function re(s, a, d) {
      for (; a; ) {
        var o = a.nextSibling;
        (d = h(a)) ? z(d) : D(
          a,
          s,
          !0
          /* skip keyed nodes */
        ), a = o;
      }
    }
    function N(s, a, d) {
      var o = h(a);
      if (o && delete k[o], !d) {
        var c = b(s, a);
        if (c === !1 || (c instanceof HTMLElement && (s = c, P(s)), i(s, a), M(s), te(s, a) === !1))
          return;
      }
      s.nodeName !== "TEXTAREA" ? ie(s, a) : K.TEXTAREA(s, a);
    }
    function ie(s, a) {
      var d = ne(s, a), o = a.firstChild, c = s.firstChild, S, y, A, O, v;
      e: for (; o; ) {
        for (O = o.nextSibling, S = h(o); !d && c; ) {
          if (A = c.nextSibling, o.isSameNode && o.isSameNode(c)) {
            o = O, c = A;
            continue e;
          }
          y = h(c);
          var C = c.nodeType, m = void 0;
          if (C === o.nodeType && (C === T ? (S ? S !== y && ((v = k[S]) ? A === v ? m = !1 : (s.insertBefore(v, c), y ? z(y) : D(
            c,
            s,
            !0
            /* skip keyed nodes */
          ), c = v, y = h(c)) : m = !1) : y && (m = !1), m = m !== !1 && _(c, o), m && N(c, o)) : (C === q || C == Y) && (m = !0, c.nodeValue !== o.nodeValue && (c.nodeValue = o.nodeValue))), m) {
            o = O, c = A;
            continue e;
          }
          y ? z(y) : D(
            c,
            s,
            !0
            /* skip keyed nodes */
          ), c = A;
        }
        if (S && (v = k[S]) && _(v, o))
          d || V(s, v), N(v, o);
        else {
          var W = g(o);
          W !== !1 && (W && (o = W), o.actualize && (o = o.actualize(s.ownerDocument || f)), V(s, o), I(o));
        }
        o = O, c = A;
      }
      re(s, c, y);
      var J = K[s.nodeName];
      J && J(s, a);
    }
    var u = t, U = u.nodeType, F = n.nodeType;
    if (!E) {
      if (U === T)
        F === T ? _(t, n) || (L(t), u = ye(t, pe(n.nodeName, n.namespaceURI))) : u = n;
      else if (U === q || U === Y) {
        if (F === U)
          return u.nodeValue !== n.nodeValue && (u.nodeValue = n.nodeValue), u;
        u = n;
      }
    }
    if (u === n)
      L(t);
    else {
      if (n.isSameNode && n.isSameNode(u))
        return;
      if (N(u, n, E), R)
        for (var x = 0, se = R.length; x < se; x++) {
          var $ = k[R[x]];
          $ && D($, $.parentNode, !1);
        }
    }
    return !E && u !== t && t.parentNode && (u.actualize && (u = u.actualize(t.ownerDocument || f)), t.parentNode.replaceChild(u, t)), u;
  };
}
var we = me(oe);
class be {
  /**
   * Creates a new Arizona client instance
   * @param {ArizonaOptions} [opts={}] - Client configuration options
   */
  constructor(e = {}) {
    this.worker = null, this.connected = !1, this.eventListeners = /* @__PURE__ */ new Map(), this.logger = e.logger || null, this.nextRefId = 0, this.pendingCalls = /* @__PURE__ */ new Map();
  }
  /**
   * Initialize worker if not already created
   * @private
   * @returns {void}
   */
  initializeWorker() {
    this.worker || (this.worker = new ae(), this.worker.onmessage = (e) => {
      this.handleWorkerMessage(e.data);
    });
  }
  /**
   * Connect to the Arizona WebSocket server
   * @param {string} websocketEndpoint - WebSocket endpoint path
   * @returns {void}
   */
  connect(e) {
    if (this.connected) return;
    this.initializeWorker();
    const t = window.location.protocol === "https:" ? "wss:" : "ws:", n = window.location.host, r = window.location.pathname, l = window.location.search, h = encodeURIComponent(r), g = l ? encodeURIComponent(l.substring(1)) : "", p = `${t}//${n}${e}?path=${h}&qs=${g}`;
    this.worker.postMessage({
      type: "connect",
      data: { url: p }
    });
  }
  /**
   * Push an event to the Arizona server
   * @param {string} event - Event name
   * @param {EventParams} [params={}] - Event parameters
   * @returns {void}
   */
  pushEvent(e, t = {}) {
    this.connected && this.worker.postMessage({
      type: "send",
      data: {
        type: "event",
        event: e,
        params: t
      }
    });
  }
  /**
   * Push an event to a specific stateful component
   * @param {string} statefulId - Target stateful component ID
   * @param {string} event - Event name
   * @param {EventParams} [params={}] - Event parameters
   * @returns {void}
   */
  pushEventTo(e, t, n = {}) {
    this.connected && this.worker.postMessage({
      type: "send",
      data: {
        type: "event",
        stateful_id: e,
        event: t,
        params: n
      }
    });
  }
  /**
   * Call an event on the Arizona server and wait for reply
   * @param {string} event - Event name
   * @param {EventParams} [params={}] - Event parameters
   * @param {Object} [options={}] - Call options
   * @param {number} [options.timeout=10000] - Timeout in milliseconds
   * @returns {Promise<*>} Promise that resolves with reply data
   */
  callEvent(e, t = {}, n = {}) {
    return this._callEvent(void 0, e, t, n);
  }
  /**
   * Call an event on a specific stateful component and wait for reply
   * @param {string} statefulId - Target stateful component ID
   * @param {string} event - Event name
   * @param {EventParams} [params={}] - Event parameters
   * @param {Object} [options={}] - Call options
   * @param {number} [options.timeout=10000] - Timeout in milliseconds
   * @returns {Promise<*>} Promise that resolves with reply data
   */
  callEventFrom(e, t, n = {}, r = {}) {
    return this._callEvent(e, t, n, r);
  }
  /**
   * Internal helper to call an event and wait for reply
   * @private
   * @param {string|undefined} statefulId - Target stateful component ID (undefined for view)
   * @param {string} event - Event name
   * @param {EventParams} params - Event parameters
   * @param {Object} options - Call options
   * @returns {Promise<*>} Promise that resolves with reply data
   */
  _callEvent(e, t, n, r) {
    if (!this.connected) return Promise.reject(new Error("Not connected"));
    const l = `${++this.nextRefId}`;
    return new Promise((h, g) => {
      const p = setTimeout(() => {
        this.pendingCalls.delete(l), g(new Error(`Call timeout: ${t}`));
      }, r.timeout || 1e4);
      this.pendingCalls.set(l, { resolve: h, reject: g, timeout: p });
      const b = {
        type: "event",
        ref_id: l,
        event: t,
        params: n
      };
      e !== void 0 && (b.stateful_id = e), this.worker.postMessage({
        type: "send",
        data: b
      });
    });
  }
  /**
   * Disconnect from the Arizona WebSocket server
   * @returns {void}
   */
  disconnect() {
    this.worker && (this.worker.terminate(), this.worker = null), this.connected = !1, this.pendingCalls.forEach((e) => {
      clearTimeout(e.timeout), e.reject(new Error("Disconnected"));
    }), this.pendingCalls.clear();
  }
  /**
   * Handle messages from the worker thread
   * @private
   * @param {Object} message - Worker message
   * @returns {void}
   */
  handleWorkerMessage(e) {
    const { type: t, data: n } = e;
    try {
      switch (t) {
        case "status":
          this.handleStatus(n);
          break;
        case "initial_render":
          break;
        case "html_patch":
          this.handleHtmlPatch(n);
          break;
        case "error":
          this.handleWorkerError(n);
          break;
        case "reload":
          this.handleReload(n);
          break;
        case "dispatch":
          this.handleDispatch(n);
          break;
        case "reply":
          this.handleReply(n);
          break;
        case "redirect":
          this.handleRedirect(n);
          break;
        default:
          this.handleUnknownMessage(e);
      }
    } catch (r) {
      this.logger?.error("Error handling worker message:", r);
    }
  }
  handleStatus(e) {
    e.status === "connected" ? (this.connected = !0, this.logger?.info("Connected to WebSocket"), this.emit("connected", e)) : e.status === "disconnected" && (this.connected = !1, this.logger?.info("Disconnected from WebSocket"), this.emit("disconnected", e));
  }
  handleHtmlPatch(e) {
    console.log("[Arizona] Received HTML patch:", e.patch), this.logger?.debug("Applying HTML patch"), this.applyHtmlPatch(e.patch);
  }
  applyHtmlPatch(e) {
    console.log("[Arizona] Applying HTML patch to", e.statefulId);
    const t = document.getElementById(e.statefulId);
    if (!t) {
      console.warn("[Arizona] Target element not found:", e.statefulId), this.logger?.warning(`Target element not found: ${e.statefulId}`);
      return;
    }
    console.log(
      "[Arizona] Target found, morphing with HTML:",
      `${e.html.substring(0, 100)}...`
    );
    try {
      we(t, e.html, {
        onBeforeElUpdated(n, r) {
          return r.dataset?.arizonaUpdate === "false" ? !1 : !n.isEqualNode(r);
        }
      }), this.logger?.debug("Patch applied successfully");
    } catch (n) {
      this.logger?.error("Error applying HTML patch:", n);
    }
  }
  handleWorkerError(e) {
    this.logger?.error("Worker Error:", e.error), this.emit("error", e);
  }
  handleReload(e) {
    switch (e.file_type) {
      case "css":
        this.logger?.info("CSS file changed. Refreshing stylesheets without page reload..."), document.querySelectorAll('link[rel="stylesheet"]').forEach((t) => {
          const n = t.href.split("?")[0];
          t.href = `${n}?t=${Date.now()}`;
        });
        break;
      default:
        this.logger?.info(`${e.file_type || "File"} changed. Reloading page...`), window.location.reload();
    }
  }
  handleDispatch(e) {
    this.logger?.debug("Dispatching event:", e.event), this.emit(e.event, e.data);
  }
  handleReply(e) {
    const { ref_id: t, data: n } = e, r = this.pendingCalls.get(t);
    r ? (clearTimeout(r.timeout), r.resolve(n), this.pendingCalls.delete(t), this.logger?.debug(`Reply received for ref: ${t}`)) : this.logger?.warning(`Received reply for unknown ref: ${t}`);
  }
  handleRedirect(e) {
    this.logger?.info("Redirecting to:", e.url), window.open(e.url, e.options?.target, e.options?.window_features);
  }
  handleUnknownMessage(e) {
    this.logger?.warning("Unknown worker message:", e);
  }
  /**
   * Check if client is connected to server
   * @returns {boolean} True if connected
   */
  isConnected() {
    return this.connected;
  }
  /**
   * Subscribe to an Arizona event
   * @param {string} event - Event name (e.g., 'connected', 'disconnected')
   * @param {Function} callback - Callback function to invoke when event occurs
   * @returns {Function} Unsubscribe function
   */
  on(e, t) {
    return typeof t != "function" ? (this.logger?.error(`on: callback must be a function, got ${typeof t}`), () => {
    }) : (this.eventListeners.has(e) || this.eventListeners.set(e, /* @__PURE__ */ new Set()), this.eventListeners.get(e).add(t), this.logger?.debug(`Subscribed to event: ${e}`), () => this.off(e, t));
  }
  /**
   * Subscribe to an Arizona event that will only fire once
   * @param {string} event - Event name
   * @param {Function} callback - Callback function to invoke when event occurs
   * @returns {Function} Unsubscribe function
   */
  once(e, t) {
    if (typeof t != "function")
      return this.logger?.error(`once: callback must be a function, got ${typeof t}`), () => {
      };
    const n = (r) => {
      t(r), this.off(e, n);
    };
    return this.on(e, n);
  }
  /**
   * Unsubscribe from an Arizona event
   * @param {string} event - Event name
   * @param {Function} callback - Callback function to remove
   * @returns {void}
   */
  off(e, t) {
    const n = this.eventListeners.get(e);
    n && (n.delete(t), this.logger?.debug(`Unsubscribed from event: ${e}`), n.size === 0 && this.eventListeners.delete(e));
  }
  /**
   * Remove all listeners for a specific event, or all events if no event specified
   * @param {string} [event] - Optional event name. If not provided, removes all listeners for all events
   * @returns {void}
   */
  removeAllListeners(e) {
    e ? (this.eventListeners.delete(e), this.logger?.debug(`Removed all listeners for event: ${e}`)) : (this.eventListeners.clear(), this.logger?.debug("Removed all event listeners"));
  }
  /**
   * Emit an Arizona event to all subscribed listeners
   * @private
   * @param {string} event - Event name
   * @param {*} data - Event data to pass to listeners
   * @returns {void}
   */
  emit(e, t) {
    const n = this.eventListeners.get(e);
    n && n.forEach((r) => {
      try {
        r(t);
      } catch (l) {
        this.logger?.error(`Error in event listener for '${e}':`, l);
      }
    });
  }
}
export {
  be as default
};
//# sourceMappingURL=arizona.min.js.map
