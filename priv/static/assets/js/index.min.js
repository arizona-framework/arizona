import { default as p } from "./arizona.min.js";
import { default as g, LOG_LEVELS as l } from "./logger/arizona-logger.min.js";
import { default as d } from "./logger/arizona-console-logger.min.js";
/*! Arizona Framework Client v0.2.0 | Apache-2.0 License */
class c {
  constructor() {
    this.structure = /* @__PURE__ */ new Map();
  }
  /**
   * Initialize with hierarchical structure from server
   * @param {Object} structure - Hierarchical structure from arizona_hierarchical
   */
  initialize(t) {
    this.structure = new Map(Object.entries(JSON.parse(JSON.stringify(t))));
  }
  /**
   * Apply diff changes from arizona_differ to hierarchical structure
   * @param {string} statefulId - Stateful ID to render
   * @param {Array|Object} changes - Changes in format: [[ElementIndex, Changes]] or hierarchical structure
   */
  applyDiff(t, i) {
    if (i?.type === "stateful") {
      this.structure.set(i.id, i);
      return;
    }
    if (!this.structure.has(t)) {
      const s = String(t).replace(/\r|\n/g, "");
      console.warn(`[Arizona] StatefulId '${s}' not found in structure`);
    }
    const r = this.structure.get(t);
    console.log("[Arizona] Applying diff to", t), console.log("[Arizona] Changes:", i), console.log(
      "[Arizona] Component dynamic before:",
      JSON.parse(JSON.stringify(r.dynamic))
    );
    for (const [s, o] of i)
      console.log("[Arizona] Applying change - index:", s, "value:", o), this.applyDiffValue(r.dynamic, s - 1, o);
    console.log(
      "[Arizona] Component dynamic after:",
      JSON.parse(JSON.stringify(r.dynamic))
    );
  }
  /**
   * Recursively apply a diff value to a container at a specific index
   * Handles all types: hierarchical structures, lists, stateless components, and simple values
   * @private
   * @param {Array} container - The dynamic array to update
   * @param {number} targetIndex - The index to update (0-based)
   * @param {*} newValue - The new value to apply
   * @returns {void}
   */
  applyDiffValue(t, i, r) {
    const s = t[i];
    if (s && typeof s == "object" && s.type === "stateful") {
      if (r && typeof r == "object" && r.type) {
        this.structure.delete(s.id), t[i] = r, r.type === "stateful" && r.static && r.dynamic && (console.log("[Arizona] Replacing stateful component in map:", r.id), this.structure.set(r.id, r));
        return;
      }
      if (Array.isArray(r)) {
        const o = this.structure.get(s.id);
        if (!o) {
          const e = String(s.id).replace(/\r|\n/g, "");
          console.warn(
            `[Arizona] Nested stateful component '${e}' not found in structure`
          );
          return;
        }
        r.forEach(([e, n]) => {
          this.applyDiffValue(o.dynamic, e - 1, n);
        });
        return;
      }
      this.structure.delete(s.id), t[i] = r;
      return;
    }
    if (r && typeof r == "object" && r.type) {
      t[i] = r, r.type === "stateful" && r.static && r.dynamic ? (console.log("[Arizona] Adding full stateful structure to map:", r.id), this.structure.set(r.id, r)) : r.type === "stateful" && console.log("[Arizona] Skipping stateful reference (no static/dynamic):", r.id);
      return;
    }
    if (Array.isArray(r)) {
      if (s && s.type === "list") {
        s.dynamic = r;
        return;
      }
      if (s && s.type === "stateless") {
        r.forEach(([o, e]) => {
          this.applyDiffValue(s.dynamic, o - 1, e);
        });
        return;
      }
      t[i] = r;
      return;
    }
    t[i] = r;
  }
  /**
   * Generate HTML for stateful components
   * @param {Object} element - Stateful element with id
   * @returns {string} Generated HTML
   */
  generateStatefulHTML(t) {
    console.log("[Arizona] generateStatefulHTML for", t);
    const i = this.structure.get(t);
    if (!i) {
      const s = String(t).replace(/\r|\n/g, "");
      throw console.warn(`[Arizona] StatefulId '${s}' not found in structure`), new Error(`Component ${s} not found`);
    }
    console.log("[Arizona] Structure found, generating HTML...");
    const r = this.zipStaticDynamic(i.static, i.dynamic);
    return console.log("[Arizona] HTML generated for", t, "length:", r.length), r;
  }
  /**
   * Generate HTML for stateless components
   * @param {Object} element - Stateless element with static and dynamic arrays
   * @returns {string} Generated HTML
   */
  generateStatelessHTML(t) {
    return this.zipStaticDynamic(t.static, t.dynamic);
  }
  /**
   * Generate HTML for list components
   * @param {Object} listElement - List element with static template and dynamic data
   * @returns {string} Generated HTML
   */
  generateListHTML(t) {
    const { static: i, dynamic: r } = t;
    return r.reduce((s, o) => s + this.zipStaticDynamic(i, o), "");
  }
  /**
   * Zip static and dynamic arrays into HTML (matches arizona_renderer:zip_static_dynamic/2)
   * @param {Array} staticParts - Static HTML parts
   * @param {Array} dynamicParts - Dynamic content parts
   * @returns {string} Generated HTML
   */
  zipStaticDynamic(t, i) {
    const r = [], s = Math.max(t.length, i.length);
    for (let o = 0; o < s; o++)
      o < t.length && r.push(t[o]), o < i.length && r.push(this.normalizeDynamicElement(i[o]));
    return r.join("");
  }
  /**
   * Normalize a dynamic element to string (handles stateful, stateless, lists, etc.)
   * @param {*} element - Dynamic element to normalize
   * @returns {string} Normalized string content
   */
  normalizeDynamicElement(t) {
    return typeof t == "string" ? t : t && t.type === "stateful" ? this.generateStatefulHTML(t.id) : t && t.type === "stateless" ? this.generateStatelessHTML(t) : t && t.type === "list" ? this.generateListHTML(t) : Array.isArray(t) ? this.flattenIoData(t) : String(t);
  }
  /**
   * Flatten nested arrays (iodata from Erlang server) into a single string
   * This handles the complex nested array structures that come from render_list
   * and other server-side rendering operations that produce iodata.
   *
   * @param {Array|string|number} element - Element to flatten
   * @returns {string} Flattened string without commas between array elements
   */
  flattenIoData(t) {
    return typeof t == "string" ? t : typeof t == "number" ? String(t) : Array.isArray(t) ? t.map((i) => this.flattenIoData(i)).join("") : t && typeof t == "object" ? t.type === "stateful" ? this.generateStatefulHTML(t.id) : t.type === "stateless" ? this.generateStatelessHTML(t) : t.type === "list" ? this.generateListHTML(t) : String(t) : String(t || "");
  }
  /**
   * Get current structure (for debugging/testing)
   * @returns {Object} Deep copy of current structure
   */
  getStructure() {
    return JSON.parse(JSON.stringify(Object.fromEntries(this.structure)));
  }
  /**
   * Check if structure has been initialized
   * @returns {boolean} True if structure contains any components
   */
  isInitialized() {
    return this.structure.size > 0;
  }
  /**
   * Get all component IDs
   * @returns {string[]} Array of all component IDs
   */
  getComponentIds() {
    return Array.from(this.structure.keys());
  }
  /**
   * Clear all structure data
   */
  clear() {
    this.structure = /* @__PURE__ */ new Map();
  }
  /**
   * Create a patch object that can be sent to arizona.js for DOM updating
   * This is used by the worker to send structured data to the main thread
   * @param {string} statefulId - Stateful ID to render
   * @returns {Object} Patch object with statefulId and HTML
   */
  createPatch(t) {
    console.log("[Arizona] createPatch called for", t);
    const i = this.generateStatefulHTML(t);
    return console.log("[Arizona] HTML generated, length:", i.length), {
      type: "html_patch",
      statefulId: t,
      html: i
    };
  }
}
export {
  p as Arizona,
  d as ArizonaConsoleLogger,
  c as ArizonaHierarchical,
  g as ArizonaLogger,
  l as LOG_LEVELS
};
//# sourceMappingURL=index.min.js.map
