{"version":3,"file":"index.min.js","sources":["../../../../assets/js/client/arizona-hierarchical.js"],"sourcesContent":["/**\n * Arizona Hierarchical Client\n *\n * Standalone module for managing hierarchical structures and HTML generation.\n * Used by both arizona-worker.js and arizona.js for consistent structure handling.\n *\n * Features:\n * - Initialize with hierarchical structures from WebSocket\n * - Apply diffs from arizona_differ to update structures\n * - Generate HTML from hierarchical structures\n * - Support for nested stateful/stateless components and lists\n */\n\n/**\n * ArizonaHierarchical - Client-side hierarchical structure manager\n */\nexport default class ArizonaHierarchical {\n  constructor() {\n    this.structure = new Map();\n  }\n\n  /**\n   * Initialize with hierarchical structure from server\n   * @param {Object} structure - Hierarchical structure from arizona_hierarchical\n   */\n  initialize(structure) {\n    this.structure = new Map(Object.entries(JSON.parse(JSON.stringify(structure)))); // Deep clone and convert to Map\n  }\n\n  /**\n   * Apply diff changes from arizona_differ to hierarchical structure\n   * @param {string} statefulId - Stateful ID to render\n   * @param {Array|Object} changes - Changes in format: [[ElementIndex, Changes]] or hierarchical structure\n   */\n  applyDiff(statefulId, changes) {\n    // Check if changes is a hierarchical structure (fingerprint mismatch case)\n    if (changes?.type === 'stateful') {\n      this.structure.set(changes.id, changes);\n      return;\n    }\n\n    if (!this.structure.has(statefulId)) {\n      const sanitizedStatefulId = String(statefulId).replace(/\\r|\\n/g, '');\n      console.warn(`[Arizona] StatefulId '${sanitizedStatefulId}' not found in structure`);\n    }\n\n    const component = this.structure.get(statefulId);\n    console.log('[Arizona] Applying diff to', statefulId);\n    console.log('[Arizona] Changes:', changes);\n    console.log(\n      '[Arizona] Component dynamic before:',\n      JSON.parse(JSON.stringify(component.dynamic))\n    );\n    for (const [elementIndex, newValue] of changes) {\n      console.log('[Arizona] Applying change - index:', elementIndex, 'value:', newValue);\n      this.applyDiffValue(component.dynamic, elementIndex - 1, newValue);\n    }\n    console.log(\n      '[Arizona] Component dynamic after:',\n      JSON.parse(JSON.stringify(component.dynamic))\n    );\n  }\n\n  /**\n   * Recursively apply a diff value to a container at a specific index\n   * Handles all types: hierarchical structures, lists, stateless components, and simple values\n   * @private\n   * @param {Array} container - The dynamic array to update\n   * @param {number} targetIndex - The index to update (0-based)\n   * @param {*} newValue - The new value to apply\n   * @returns {void}\n   */\n  applyDiffValue(container, targetIndex, newValue) {\n    const existingElement = container[targetIndex];\n\n    // 1. Handle existing stateful component references\n    if (\n      existingElement &&\n      typeof existingElement === 'object' &&\n      existingElement.type === 'stateful'\n    ) {\n      // 1a. If newValue is a hierarchical structure, replace the old component\n      if (newValue && typeof newValue === 'object' && newValue.type) {\n        // Remove old stateful component from structure\n        this.structure.delete(existingElement.id);\n        // Replace with new structure\n        container[targetIndex] = newValue;\n        // If new value is also stateful with full structure, add it to structure\n        if (newValue.type === 'stateful' && newValue.static && newValue.dynamic) {\n          console.log('[Arizona] Replacing stateful component in map:', newValue.id);\n          this.structure.set(newValue.id, newValue);\n        }\n        return;\n      }\n\n      // 1b. If newValue is an array, it's a diff for the nested component\n      if (Array.isArray(newValue)) {\n        const statefulComponent = this.structure.get(existingElement.id);\n        if (!statefulComponent) {\n          const sanitizedId = String(existingElement.id).replace(/\\r|\\n/g, '');\n          console.warn(\n            `[Arizona] Nested stateful component '${sanitizedId}' not found in structure`\n          );\n          return;\n        }\n        // Recursively apply diff changes to the nested component's dynamic array\n        newValue.forEach(([elementIndex, elementValue]) => {\n          this.applyDiffValue(statefulComponent.dynamic, elementIndex - 1, elementValue);\n        });\n        return;\n      }\n\n      // 1c. If newValue is a simple value, component was removed from template\n      // Remove from structure and replace with simple value\n      this.structure.delete(existingElement.id);\n      container[targetIndex] = newValue;\n      return;\n    }\n\n    // 2. Check if newValue is a hierarchical structure (fingerprint mismatch)\n    if (newValue && typeof newValue === 'object' && newValue.type) {\n      container[targetIndex] = newValue;\n      // If it's a stateful component with full structure, add to structure map\n      // Only add if it has static/dynamic arrays (full structure), not just a reference\n      if (newValue.type === 'stateful' && newValue.static && newValue.dynamic) {\n        console.log('[Arizona] Adding full stateful structure to map:', newValue.id);\n        this.structure.set(newValue.id, newValue);\n      } else if (newValue.type === 'stateful') {\n        console.log('[Arizona] Skipping stateful reference (no static/dynamic):', newValue.id);\n      }\n      return;\n    }\n\n    // 3. Check if newValue is an array (nested diff or list data)\n    if (Array.isArray(newValue)) {\n      // 3a. If existing element is a list, replace its dynamic data\n      if (existingElement && existingElement.type === 'list') {\n        existingElement.dynamic = newValue;\n        return;\n      }\n\n      // 3b. If existing element is stateless, apply nested diff recursively\n      if (existingElement && existingElement.type === 'stateless') {\n        newValue.forEach(([index, value]) => {\n          this.applyDiffValue(existingElement.dynamic, index - 1, value);\n        });\n        return;\n      }\n\n      // 3c. Otherwise, replace with array value\n      container[targetIndex] = newValue;\n      return;\n    }\n\n    // 4. Simple value - just replace\n    container[targetIndex] = newValue;\n  }\n\n  /**\n   * Generate HTML for stateful components\n   * @param {Object} element - Stateful element with id\n   * @returns {string} Generated HTML\n   */\n  generateStatefulHTML(statefulId) {\n    console.log('[Arizona] generateStatefulHTML for', statefulId);\n    const struct = this.structure.get(statefulId);\n    if (!struct) {\n      const sanitizedStatefulId = String(statefulId).replace(/\\r|\\n/g, '');\n      console.warn(`[Arizona] StatefulId '${sanitizedStatefulId}' not found in structure`);\n      throw new Error(`Component ${sanitizedStatefulId} not found`);\n    }\n\n    console.log('[Arizona] Structure found, generating HTML...');\n    // Components always have static and dynamic arrays\n    const html = this.zipStaticDynamic(struct.static, struct.dynamic);\n    console.log('[Arizona] HTML generated for', statefulId, 'length:', html.length);\n    return html;\n  }\n\n  /**\n   * Generate HTML for stateless components\n   * @param {Object} element - Stateless element with static and dynamic arrays\n   * @returns {string} Generated HTML\n   */\n  generateStatelessHTML(element) {\n    return this.zipStaticDynamic(element.static, element.dynamic);\n  }\n\n  /**\n   * Generate HTML for list components\n   * @param {Object} listElement - List element with static template and dynamic data\n   * @returns {string} Generated HTML\n   */\n  generateListHTML(listElement) {\n    const { static: staticParts, dynamic: dynamicPartsList } = listElement;\n    return dynamicPartsList.reduce((acc, dynamicParts) => {\n      return acc + this.zipStaticDynamic(staticParts, dynamicParts);\n    }, '');\n  }\n\n  /**\n   * Zip static and dynamic arrays into HTML (matches arizona_renderer:zip_static_dynamic/2)\n   * @param {Array} staticParts - Static HTML parts\n   * @param {Array} dynamicParts - Dynamic content parts\n   * @returns {string} Generated HTML\n   */\n  zipStaticDynamic(staticParts, dynamicParts) {\n    const elements = [];\n    const maxLength = Math.max(staticParts.length, dynamicParts.length);\n\n    for (let i = 0; i < maxLength; i++) {\n      if (i < staticParts.length) {\n        elements.push(staticParts[i]);\n      }\n      if (i < dynamicParts.length) {\n        elements.push(this.normalizeDynamicElement(dynamicParts[i]));\n      }\n    }\n\n    return elements.join('');\n  }\n\n  /**\n   * Normalize a dynamic element to string (handles stateful, stateless, lists, etc.)\n   * @param {*} element - Dynamic element to normalize\n   * @returns {string} Normalized string content\n   */\n  normalizeDynamicElement(element) {\n    if (typeof element === 'string') {\n      return element;\n    } else if (element && element.type === 'stateful') {\n      // Recursively render nested stateful component\n      return this.generateStatefulHTML(element.id);\n    } else if (element && element.type === 'stateless') {\n      // Render stateless structure inline\n      return this.generateStatelessHTML(element);\n    } else if (element && element.type === 'list') {\n      // Render list elements\n      return this.generateListHTML(element);\n    } else if (Array.isArray(element)) {\n      // Handle nested arrays (iodata from server) - flatten recursively\n      return this.flattenIoData(element);\n    } else {\n      // Fallback for other types (numbers, etc.)\n      return String(element);\n    }\n  }\n\n  /**\n   * Flatten nested arrays (iodata from Erlang server) into a single string\n   * This handles the complex nested array structures that come from render_list\n   * and other server-side rendering operations that produce iodata.\n   *\n   * @param {Array|string|number} element - Element to flatten\n   * @returns {string} Flattened string without commas between array elements\n   */\n  flattenIoData(element) {\n    if (typeof element === 'string') {\n      return element;\n    } else if (typeof element === 'number') {\n      return String(element);\n    } else if (Array.isArray(element)) {\n      // Recursively flatten nested arrays\n      return element\n        .map((item) => {\n          return this.flattenIoData(item);\n        })\n        .join('');\n    } else if (element && typeof element === 'object') {\n      // Handle special object types\n      if (element.type === 'stateful') {\n        return this.generateStatefulHTML(element.id);\n      } else if (element.type === 'stateless') {\n        return this.generateStatelessHTML(element);\n      } else if (element.type === 'list') {\n        return this.generateListHTML(element);\n      } else {\n        // For other objects, try to convert to string\n        return String(element);\n      }\n    } else {\n      // Fallback for null, undefined, etc.\n      return String(element || '');\n    }\n  }\n\n  /**\n   * Get current structure (for debugging/testing)\n   * @returns {Object} Deep copy of current structure\n   */\n  getStructure() {\n    return JSON.parse(JSON.stringify(Object.fromEntries(this.structure)));\n  }\n\n  /**\n   * Check if structure has been initialized\n   * @returns {boolean} True if structure contains any components\n   */\n  isInitialized() {\n    return this.structure.size > 0;\n  }\n\n  /**\n   * Get all component IDs\n   * @returns {string[]} Array of all component IDs\n   */\n  getComponentIds() {\n    return Array.from(this.structure.keys());\n  }\n\n  /**\n   * Clear all structure data\n   */\n  clear() {\n    this.structure = new Map();\n  }\n\n  /**\n   * Create a patch object that can be sent to arizona.js for DOM updating\n   * This is used by the worker to send structured data to the main thread\n   * @param {string} statefulId - Stateful ID to render\n   * @returns {Object} Patch object with statefulId and HTML\n   */\n  createPatch(statefulId) {\n    console.log('[Arizona] createPatch called for', statefulId);\n    const html = this.generateStatefulHTML(statefulId);\n    console.log('[Arizona] HTML generated, length:', html.length);\n    return {\n      type: 'html_patch',\n      statefulId,\n      html,\n    };\n  }\n}\n"],"names":["ArizonaHierarchical","structure","statefulId","changes","sanitizedStatefulId","component","elementIndex","newValue","container","targetIndex","existingElement","statefulComponent","sanitizedId","elementValue","index","value","struct","html","element","listElement","staticParts","dynamicPartsList","acc","dynamicParts","elements","maxLength","i","item"],"mappings":";;;;AAgBe,MAAMA,EAAoB;AAAA,EACvC,cAAc;AACZ,SAAK,YAAY,oBAAI,IAAG;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAWC,GAAW;AACpB,SAAK,YAAY,IAAI,IAAI,OAAO,QAAQ,KAAK,MAAM,KAAK,UAAUA,CAAS,CAAC,CAAC,CAAC;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAUC,GAAYC,GAAS;AAE7B,QAAIA,GAAS,SAAS,YAAY;AAChC,WAAK,UAAU,IAAIA,EAAQ,IAAIA,CAAO;AACtC;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,UAAU,IAAID,CAAU,GAAG;AACnC,YAAME,IAAsB,OAAOF,CAAU,EAAE,QAAQ,UAAU,EAAE;AACnE,cAAQ,KAAK,yBAAyBE,CAAmB,0BAA0B;AAAA,IACrF;AAEA,UAAMC,IAAY,KAAK,UAAU,IAAIH,CAAU;AAC/C,YAAQ,IAAI,8BAA8BA,CAAU,GACpD,QAAQ,IAAI,sBAAsBC,CAAO,GACzC,QAAQ;AAAA,MACN;AAAA,MACA,KAAK,MAAM,KAAK,UAAUE,EAAU,OAAO,CAAC;AAAA,IAClD;AACI,eAAW,CAACC,GAAcC,CAAQ,KAAKJ;AACrC,cAAQ,IAAI,sCAAsCG,GAAc,UAAUC,CAAQ,GAClF,KAAK,eAAeF,EAAU,SAASC,IAAe,GAAGC,CAAQ;AAEnE,YAAQ;AAAA,MACN;AAAA,MACA,KAAK,MAAM,KAAK,UAAUF,EAAU,OAAO,CAAC;AAAA,IAClD;AAAA,EACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,eAAeG,GAAWC,GAAaF,GAAU;AAC/C,UAAMG,IAAkBF,EAAUC,CAAW;AAG7C,QACEC,KACA,OAAOA,KAAoB,YAC3BA,EAAgB,SAAS,YACzB;AAEA,UAAIH,KAAY,OAAOA,KAAa,YAAYA,EAAS,MAAM;AAE7D,aAAK,UAAU,OAAOG,EAAgB,EAAE,GAExCF,EAAUC,CAAW,IAAIF,GAErBA,EAAS,SAAS,cAAcA,EAAS,UAAUA,EAAS,YAC9D,QAAQ,IAAI,kDAAkDA,EAAS,EAAE,GACzE,KAAK,UAAU,IAAIA,EAAS,IAAIA,CAAQ;AAE1C;AAAA,MACF;AAGA,UAAI,MAAM,QAAQA,CAAQ,GAAG;AAC3B,cAAMI,IAAoB,KAAK,UAAU,IAAID,EAAgB,EAAE;AAC/D,YAAI,CAACC,GAAmB;AACtB,gBAAMC,IAAc,OAAOF,EAAgB,EAAE,EAAE,QAAQ,UAAU,EAAE;AACnE,kBAAQ;AAAA,YACN,wCAAwCE,CAAW;AAAA,UAC/D;AACU;AAAA,QACF;AAEA,QAAAL,EAAS,QAAQ,CAAC,CAACD,GAAcO,CAAY,MAAM;AACjD,eAAK,eAAeF,EAAkB,SAASL,IAAe,GAAGO,CAAY;AAAA,QAC/E,CAAC;AACD;AAAA,MACF;AAIA,WAAK,UAAU,OAAOH,EAAgB,EAAE,GACxCF,EAAUC,CAAW,IAAIF;AACzB;AAAA,IACF;AAGA,QAAIA,KAAY,OAAOA,KAAa,YAAYA,EAAS,MAAM;AAC7D,MAAAC,EAAUC,CAAW,IAAIF,GAGrBA,EAAS,SAAS,cAAcA,EAAS,UAAUA,EAAS,WAC9D,QAAQ,IAAI,oDAAoDA,EAAS,EAAE,GAC3E,KAAK,UAAU,IAAIA,EAAS,IAAIA,CAAQ,KAC/BA,EAAS,SAAS,cAC3B,QAAQ,IAAI,8DAA8DA,EAAS,EAAE;AAEvF;AAAA,IACF;AAGA,QAAI,MAAM,QAAQA,CAAQ,GAAG;AAE3B,UAAIG,KAAmBA,EAAgB,SAAS,QAAQ;AACtD,QAAAA,EAAgB,UAAUH;AAC1B;AAAA,MACF;AAGA,UAAIG,KAAmBA,EAAgB,SAAS,aAAa;AAC3D,QAAAH,EAAS,QAAQ,CAAC,CAACO,GAAOC,CAAK,MAAM;AACnC,eAAK,eAAeL,EAAgB,SAASI,IAAQ,GAAGC,CAAK;AAAA,QAC/D,CAAC;AACD;AAAA,MACF;AAGA,MAAAP,EAAUC,CAAW,IAAIF;AACzB;AAAA,IACF;AAGA,IAAAC,EAAUC,CAAW,IAAIF;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAAqBL,GAAY;AAC/B,YAAQ,IAAI,sCAAsCA,CAAU;AAC5D,UAAMc,IAAS,KAAK,UAAU,IAAId,CAAU;AAC5C,QAAI,CAACc,GAAQ;AACX,YAAMZ,IAAsB,OAAOF,CAAU,EAAE,QAAQ,UAAU,EAAE;AACnE,oBAAQ,KAAK,yBAAyBE,CAAmB,0BAA0B,GAC7E,IAAI,MAAM,aAAaA,CAAmB,YAAY;AAAA,IAC9D;AAEA,YAAQ,IAAI,+CAA+C;AAE3D,UAAMa,IAAO,KAAK,iBAAiBD,EAAO,QAAQA,EAAO,OAAO;AAChE,mBAAQ,IAAI,gCAAgCd,GAAY,WAAWe,EAAK,MAAM,GACvEA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,sBAAsBC,GAAS;AAC7B,WAAO,KAAK,iBAAiBA,EAAQ,QAAQA,EAAQ,OAAO;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiBC,GAAa;AAC5B,UAAM,EAAE,QAAQC,GAAa,SAASC,EAAgB,IAAKF;AAC3D,WAAOE,EAAiB,OAAO,CAACC,GAAKC,MAC5BD,IAAM,KAAK,iBAAiBF,GAAaG,CAAY,GAC3D,EAAE;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiBH,GAAaG,GAAc;AAC1C,UAAMC,IAAW,CAAA,GACXC,IAAY,KAAK,IAAIL,EAAY,QAAQG,EAAa,MAAM;AAElE,aAASG,IAAI,GAAGA,IAAID,GAAWC;AAC7B,MAAIA,IAAIN,EAAY,UAClBI,EAAS,KAAKJ,EAAYM,CAAC,CAAC,GAE1BA,IAAIH,EAAa,UACnBC,EAAS,KAAK,KAAK,wBAAwBD,EAAaG,CAAC,CAAC,CAAC;AAI/D,WAAOF,EAAS,KAAK,EAAE;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,wBAAwBN,GAAS;AAC/B,WAAI,OAAOA,KAAY,WACdA,IACEA,KAAWA,EAAQ,SAAS,aAE9B,KAAK,qBAAqBA,EAAQ,EAAE,IAClCA,KAAWA,EAAQ,SAAS,cAE9B,KAAK,sBAAsBA,CAAO,IAChCA,KAAWA,EAAQ,SAAS,SAE9B,KAAK,iBAAiBA,CAAO,IAC3B,MAAM,QAAQA,CAAO,IAEvB,KAAK,cAAcA,CAAO,IAG1B,OAAOA,CAAO;AAAA,EAEzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,cAAcA,GAAS;AACrB,WAAI,OAAOA,KAAY,WACdA,IACE,OAAOA,KAAY,WACrB,OAAOA,CAAO,IACZ,MAAM,QAAQA,CAAO,IAEvBA,EACJ,IAAI,CAACS,MACG,KAAK,cAAcA,CAAI,CAC/B,EACA,KAAK,EAAE,IACDT,KAAW,OAAOA,KAAY,WAEnCA,EAAQ,SAAS,aACZ,KAAK,qBAAqBA,EAAQ,EAAE,IAClCA,EAAQ,SAAS,cACnB,KAAK,sBAAsBA,CAAO,IAChCA,EAAQ,SAAS,SACnB,KAAK,iBAAiBA,CAAO,IAG7B,OAAOA,CAAO,IAIhB,OAAOA,KAAW,EAAE;AAAA,EAE/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe;AACb,WAAO,KAAK,MAAM,KAAK,UAAU,OAAO,YAAY,KAAK,SAAS,CAAC,CAAC;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB;AACd,WAAO,KAAK,UAAU,OAAO;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB;AAChB,WAAO,MAAM,KAAK,KAAK,UAAU,KAAI,CAAE;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,SAAK,YAAY,oBAAI,IAAG;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAYhB,GAAY;AACtB,YAAQ,IAAI,oCAAoCA,CAAU;AAC1D,UAAMe,IAAO,KAAK,qBAAqBf,CAAU;AACjD,mBAAQ,IAAI,qCAAqCe,EAAK,MAAM,GACrD;AAAA,MACL,MAAM;AAAA,MACN,YAAAf;AAAA,MACA,MAAAe;AAAA,IACN;AAAA,EACE;AACF;"}