-module(arizona_parser).
-moduledoc ~"""
Template parser for Arizona Web Framework.

This module converts tokenized Arizona templates into structured data
for different rendering modes. It processes tokens generated by `arizona_scanner`
and organizes them into appropriate data structures for template rendering.

## Parsing Modes

### Stateless Parsing

Returns a simple list of tokens for lightweight template rendering:
```erlang
[{static, 1, <<"Hello ">>}, {dynamic, 1, <<"Name">>}, {static, 1, <<"!">>}]
```

### Stateful Parsing

Returns structured data with element ordering and mapping for efficient updates:
```erlang
#{
    elems_order => [0, 1, 2],
    elems => #{
        0 => {static, 1, <<"Hello ">>},
        1 => {dynamic, 1, <<"Name">>},
        2 => {static, 1, <<"!">>}
    }
}
```

### List Parsing

Returns separated static and dynamic parts optimized for list rendering.

## Key Features

- **Multiple Output Formats**: Supports stateless, stateful, and list parsing modes
- **Element Organization**: Creates ordered structures with indexed element mapping
- **Line Number Preservation**: Maintains source location information for debugging
- **Comment Filtering**: Removes comment tokens while preserving content tokens
- **Clean Structure**: Focuses on template organization without variable analysis

The parser creates the foundation data structures that enable efficient
template rendering and updates across different Arizona rendering modes.
""".

%% --------------------------------------------------------------------
%% API function exports
%% --------------------------------------------------------------------

-export([parse_stateless_tokens/1]).
-export([parse_stateful_tokens/1]).
-export([parse_list_tokens/1]).

%% --------------------------------------------------------------------
%% Types exports
%% --------------------------------------------------------------------

-export_type([token/0]).
-export_type([stateless_result/0]).
-export_type([stateful_result/0]).
-export_type([list_result/0]).

%% --------------------------------------------------------------------
%% Types definitions
%% --------------------------------------------------------------------

-doc ~"""
Token representation with category, line number, and content.
""".
-type token() :: {
    Category :: static | dynamic | comment, Line :: pos_integer(), Content :: binary()
}.

-doc ~"""
Result type for stateless parsing - list of tokens with comments filtered out.
""".
-type stateless_result() :: [
    Token :: {
        Category :: static | dynamic, Line :: pos_integer(), Content :: binary()
    }
].

-doc ~"""
Result type for stateful parsing with element ordering and element mapping.

The parse transform will handle variable analysis and add vars_indexes separately.
""".
-type stateful_result() :: #{
    elems_order := [Index :: non_neg_integer()],
    elems := #{
        Index ::
            non_neg_integer() => {
                Category :: static | dynamic, Line :: pos_integer(), Content :: binary()
            }
    }
}.

-doc ~"""
Result type for list parsing with static/dynamic template structure.

Runtime fallback format - parse transform will optimize to arizona_renderer:list_template_data().
The parse transform will handle variable analysis and add vars_indexes separately.
""".
-type list_result() :: #{
    static := [StaticContent :: binary()],
    dynamic := #{
        elems_order := [Index :: non_neg_integer()],
        elems := #{
            Index ::
                non_neg_integer() => {
                    Category :: dynamic,
                    Line :: pos_integer(),
                    ExprText :: binary()
                }
        }
    }
}.

%% --------------------------------------------------------------------
%% API Functions
%% --------------------------------------------------------------------

-doc ~"""
Parse tokens into stateless iolist structure.

Converts a list of tokens into a structure suitable for stateless rendering.
Filters out comment tokens while preserving static and dynamic tokens with
their line numbers intact.

Returns a list of tokens that can be directly processed by template renderers.
""".
-spec parse_stateless_tokens(Tokens) -> Result when
    Tokens :: [token()],
    Result :: stateless_result().
parse_stateless_tokens(Tokens) ->
    [Token || {Category, _Line, _Text} = Token <- Tokens, Category =/= comment].

-doc ~"""
Parse tokens into stateful template structure.

Converts a list of tokens into a structured format for stateful rendering.
This includes element ordering and element mapping.

The resulting map contains:
- `elems_order`: Sequential list of element indices
- `elems`: Map of element index to token data

Variable analysis and vars_indexes generation is handled by the parse transform.
""".
-spec parse_stateful_tokens(Tokens) -> Result when
    Tokens :: [token()],
    Result :: stateful_result().
parse_stateful_tokens(Tokens) ->
    Elements = process_tokens_stateful(Tokens, 0, #{}),
    #{
        elems_order => lists:seq(0, maps:size(Elements) - 1),
        elems => Elements
    }.

-doc ~"""
Parse tokens into list template structure.

For now, this is a simple placeholder that will be enhanced by parse transform.
The structure separates static HTML parts from dynamic expressions for efficient
list rendering with minimal re-computation.
""".
-spec parse_list_tokens(Tokens) -> Result when
    Tokens :: [token()],
    Result :: list_result().
parse_list_tokens(Tokens) ->
    %% For runtime: simple fallback structure
    %% Parse transform will provide optimized version
    {StaticParts, DynamicElements} = process_tokens_for_list(Tokens),
    #{
        static => StaticParts,
        dynamic => #{
            elems_order => lists:seq(0, maps:size(DynamicElements) - 1),
            elems => DynamicElements
        }
    }.

%% --------------------------------------------------------------------
%% Private functions
%% --------------------------------------------------------------------

%% Process tokens for stateful structure
process_tokens_stateful([], _Index, Elements) ->
    Elements;
process_tokens_stateful([Token | Rest], Index, Elements) ->
    case Token of
        {static, Line, Text} ->
            NewElements = Elements#{Index => {static, Line, Text}},
            process_tokens_stateful(Rest, Index + 1, NewElements);
        {dynamic, Line, ExprText} ->
            %% Keep original expression text - parse transform will handle variable analysis
            NewElements = Elements#{Index => {dynamic, Line, ExprText}},
            process_tokens_stateful(Rest, Index + 1, NewElements);
        {comment, _Line, _Text} ->
            %% Skip comments (don't increment index)
            process_tokens_stateful(Rest, Index, Elements)
    end.

%% Variable extraction functions removed - parse transform handles variable analysis

%% Process tokens for list template structure (similar to stateful but different output)
process_tokens_for_list(Tokens) ->
    %% For runtime fallback: create simple structure
    %% Parse transform will optimize this
    separate_static_dynamic_for_list(Tokens, [], #{}, 0, undefined).

%% Separate static and dynamic parts for list rendering
separate_static_dynamic_for_list([], StaticAcc, DynamicAcc, _Index, _PrevType) ->
    {lists:reverse(StaticAcc), DynamicAcc};
separate_static_dynamic_for_list(
    [{static, _Line, Text} | Rest], StaticAcc, DynamicAcc, Index, _PrevType
) ->
    separate_static_dynamic_for_list(Rest, [Text | StaticAcc], DynamicAcc, Index, static);
separate_static_dynamic_for_list(
    [{dynamic, Line, ExprText} | Rest], StaticAcc, DynamicAcc, Index, PrevType
) ->
    %% Store dynamic element - parse transform will handle variable analysis
    NewDynamicAcc = DynamicAcc#{Index => {dynamic, Line, ExprText}},

    %% Add empty static part when:
    %% 1. First token is dynamic (PrevType == undefined)
    %% 2. Previous token was also dynamic (PrevType == dynamic)
    NewStaticAcc =
        case PrevType of
            % First token is dynamic
            undefined -> [~"" | StaticAcc];
            % Consecutive dynamics
            dynamic -> [~"" | StaticAcc];
            % After static, no empty needed
            static -> StaticAcc
        end,

    separate_static_dynamic_for_list(
        Rest, NewStaticAcc, NewDynamicAcc, Index + 1, dynamic
    );
separate_static_dynamic_for_list(
    [{comment, _Line, _Text} | Rest], StaticAcc, DynamicAcc, Index, PrevType
) ->
    %% Skip comments - preserve previous type
    separate_static_dynamic_for_list(Rest, StaticAcc, DynamicAcc, Index, PrevType).
